<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />

<title>Week 7 Syntax Notebook</title>


<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>



<div class="pageContent band">
<div class="bandContent page">

<div class="topics">

<div id="section-introduction" class="section level2">
<h2><strong>Introduction</strong></h2>
<p>This tutorial will demonstrate use of the R commands used in community detection algorithms, as introduced in Week 7’s Lecture. We will look at five possible steps in a community analysis:</p>
<p><em>Identify communities </em>Inspect density of ties within and between communities <em>Create a community indicator in node measures dataframe </em>Plot network with community coloring *Compare estimated community partitions</p>
<p>We will introduce several different community detection algorithms:</p>
<ul>
<li>Fast and Greedy</li>
<li>Modularity</li>
<li>Leading Label Propogation</li>
<li>Edge Betweenness</li>
<li>Eigenvector</li>
<li>Spinglass</li>
</ul>
<p>In addition to the Florentine marriages dataset used for the examples, this tutorial includes access to the GoT marriage network and two airport networks: one is weighted based on distance between the airports (<em>airports.geo…</em>) and the other is weighted based on the number of flights between two airports (<em>airports.fl…</em>). The edge attribute is called “weight”&quot; for the igraph networks, but has a distinct name in the statnet networks. The airport networks are not perfectly symmetric for some unknown reason, and thus read in as directed networks. There is also a network created from alliances data in Correlates of War, <em>alliances.ig</em> and <em>alliances.stat</em>.</p>
</div>
<div id="section-basic-network-description" class="section level2">
<h2><strong>Basic Network Description</strong></h2>
<div id="section-inspect-basic-network-descriptors" class="section level3">
<h3>1. Inspect basic <strong>network descriptors</strong></h3>
<p>Inspect the network attributes of the <code>airports.fl.stat</code> and <code>airports.geo.stat</code> networks. For this exercise, refer to Week 1 tutorial. This will help you get familiar with the dataset you are using.</p>
<p>Find network size, type (un/directed, un/weighted, bipartite) and available attributes of vertices and edges</p>
<div class="tutorial-exercise" data-label="describe" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Find network size and type</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="describe-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Find network size and type
print(alliances.stat)
print(airports.fl.stat)
print(airports.geo.stat)
print(flomarr.stat)
print(gotmarr.stat)</code></pre>
</div>
</div>
<div id="section-inspect-the-network-structure" class="section level3">
<h3>2. Inspect the Network Structure</h3>
<p>Inspect the <strong>dyads, triads, and component structure</strong> of the <code>airports.fl.stat</code> and <code>airports.geo.stat</code> networks. Pay attention to whether network is connected, as it affects the otions you use for closeness centrality.</p>
<div class="tutorial-exercise" data-label="structure" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Dyad census, triad census, number and size of components, isolates. Also look at the density and transitivity values</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="structure-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Dyad census, triad census, number and size of components, isolates, density and transitivity
gden(alliances.stat)
gtrans(alliances.stat)
igraph::components(alliances.ig)$no
summary(E(alliances.ig)$weight)

gden(airports.geo.stat)
gtrans(airports.geo.stat)
igraph::components(airports.geo.ig)$no
summary(airports.geo.stat%e%&quot;dist&quot;)

gden(airports.fl.stat)
gtrans(airports.fl.stat)
igraph::components(airports.fl.ig)$no
summary(airports.fl.stat%e%&quot;flights&quot;)</code></pre>
</div>
</div>
<div id="section-create-a-network.nodes-dataframe" class="section level3">
<h3>3. Create a <em>network</em>.nodes dataframe</h3>
<p>Create a dataframe of standard, applicable node-level measures (from weeks 3-5.) See the routine developed in week 6, as well as the specialized functions for derived and reflected centrality and network brokerage.</p>
<div class="tutorial-exercise" data-label="nodes" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#create dataframe with names
#add degree if undirected
#add degree.wt if weighted (and makes sense)
#else add indegree and outdegree if directed
#add sna::bompow for non-singular, unweighted matrix
#else add igraph::power_centrality()
#add betweenness, set gmode for undirected
#add closeness, set gmode for undirected and cmode if not connected
#add constraint (igraph)

#add eigenvector centrality using custom function

#add brokerage using custom func. if vertex attribute + directed</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="nodes-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>alliances.nodes&lt;-data.frame(name=alliances.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(alliances.stat,gmode=&quot;digraph&quot;),
        degree.wt=strength(alliances.ig),
        betweenness=sna::betweenness(alliances.stat, gmode=&quot;digraph&quot;),
        close=sna::closeness(alliances.stat, cmode=&quot;suminvdir&quot;),
        constraint=constraint(alliances.ig)
        )
alliances.nodes&lt;-full_join(alliances.nodes,get.eigen(alliances.stat), by=&quot;name&quot;)

airports.fl.nodes&lt;-data.frame(name=airports.fl.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(airports.fl.stat,gmode=&quot;digraph&quot;),
        degree.wt=strength(airports.fl.ig),
        betweenness=sna::betweenness(airports.fl.stat),
        close=sna::closeness(airports.fl.stat, gmode=&quot;digraph&quot;),
        constraint=constraint(airports.fl.ig))
airports.fl.nodes&lt;-full_join(airports.fl.nodes,get.eigen(airports.fl.stat), by=&quot;name&quot;)

airports.geo.nodes&lt;- data.frame(name=airports.geo.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(airports.geo.stat,gmode=&quot;digraph&quot;),
        degree.wt=strength(airports.geo.ig),
        betweenness=sna::betweenness(airports.geo.stat),
        close=sna::closeness(airports.geo.stat, gmode=&quot;digraph&quot;))
airports.geo.nodes&lt;-full_join(airports.geo.nodes,get.eigen(airports.geo.stat), by=&quot;name&quot;)

flomarr.nodes&lt;-data.frame(name=flomarr.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(flomarr.stat,gmode=&quot;graph&quot;),
        betweenness=sna::betweenness(flomarr.stat, gmode=&quot;graph&quot;),
        close=sna::closeness(flomarr.stat, gmode=&quot;graph&quot;),
        constraint=constraint(flomarr.ig))
flomarr.nodes&lt;-full_join(flomarr.nodes,get.eigen(flomarr.stat), by=&quot;name&quot;)

gotmarr.nodes&lt;-data.frame(name=gotmarr.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(gotmarr.stat,gmode=&quot;graph&quot;),
        degree.wt=strength(gotmarr.ig),
        bonpow=sna::bonpow(gotmarr.stat),
        betweenness=sna::betweenness(gotmarr.stat, gmode=&quot;graph&quot;),
        close=sna::closeness(gotmarr.stat, gmode=&quot;graph&quot;),
        constraint=constraint(gotmarr.ig))
gotmarr.nodes&lt;-full_join(gotmarr.nodes,get.eigen(gotmarr.stat, &quot;weight&quot;), by=&quot;name&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-fast-and-greedy-community-detection" class="section level2">
<h2><strong>Fast and Greedy Community Detection</strong></h2>
<p>This method tries to detect particularly dense subgraphs by optimizing modularity scores. (See <a href="http://www.arxiv.org/abs/cond-mat/0408187" class="uri">http://www.arxiv.org/abs/cond-mat/0408187</a>) It is often tried first for simplicity because it has no parameters to tune. This algorithm is part of the igraph package, and thus you must specify an igraph object. It only works on undirected graphs, or directed graphs must be converted to undirected.</p>
<pre class="r"><code>#Run clustering algorithm: fast_greedy
comm.fg&lt;-cluster_fast_greedy(flomarr.ig)
#Inspect clustering object
names(comm.fg)</code></pre>
<pre><code>## [1] &quot;merges&quot;     &quot;modularity&quot; &quot;membership&quot; &quot;names&quot;      &quot;algorithm&quot; 
## [6] &quot;vcount&quot;</code></pre>
<pre class="r"><code>comm.fg</code></pre>
<pre><code>## IGRAPH clustering fast greedy, groups: 4, mod: 0.44
## + groups:
##   $`1`
##   [1] &quot;Acciaiuoli&quot; &quot;Medici&quot;     &quot;Pazzi&quot;      &quot;Ridolfi&quot;    &quot;Salviati&quot;  
##   [6] &quot;Tornabuoni&quot;
##   
##   $`2`
##   [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
##   
##   $`3`
##   [1] &quot;Barbadori&quot;  &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
##   
##   + ... omitted several groups/vertices</code></pre>
<p>As can be seen in the R output, the resulting <code>communities</code> object consists of a significant amount of information, including the optimzed (final) modularity score, a community membership vector, and a specification of which algorithm was used to extract communities. This allows us to compare modularity scores across different clustering algorithms, and also extract membership vectors as described below.</p>
<p>In order to see a complete list of which nodes belong to which clusters, we can easily retrieve this information using <code>groups</code>.</p>
<pre class="r"><code>#retrieve list of nodes in communities
igraph::groups(comm.fg)</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot; &quot;Medici&quot;     &quot;Pazzi&quot;      &quot;Ridolfi&quot;    &quot;Salviati&quot;  
## [6] &quot;Tornabuoni&quot;
## 
## $`2`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## 
## $`3`
## [1] &quot;Barbadori&quot;  &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Pucci&quot;</code></pre>
<div id="section-exercise-community-cluster" class="section level3">
<h3>Exercise: Community cluster</h3>
<p>Now, using one of the other networks provided this week, try running the fast, greedy algorithm to partition the network into communities and then retrieve the list of vertex names in each community. Note that if the network is directed, you will need to call the function <code>as.undirected()</code> in order to get this function to work.</p>
<div class="tutorial-exercise" data-label="cluster" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: fast_greedy

#Retrieve list of nodes in communities</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="cluster-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: fast_greedy
got.fg&lt;-cluster_fast_greedy(gotmarr.ig)
#Retrieve list of nodes in communities
igraph::groups(got.fg)

#other example networks
alliances.fg&lt;-cluster_fast_greedy(alliances.ig)
igraph::groups(alliances.fg)
airports.fl.fg&lt;-cluster_fast_greedy(as.undirected(airports.fl.ig))
igraph::groups(airports.fl.fg)
airports.geo.fg&lt;-cluster_fast_greedy(as.undirected(airports.geo.ig))
igraph::groups(airports.geo.fg)</code></pre>
</div>
</div>
</div>
<div id="section-inspect-community-density" class="section level2">
<h2>Inspect Community Density</h2>
<p>The substantive goal of community detection is often to identify groups of nodes with a higher density of ties within communities than between communities. The easiest way to quickly calculate the density of ties within and between communities is to use the <code>blockmodel</code> funciton and simply provide the community membership vector in place of a clustering object.</p>
<pre class="r"><code>#blockmodel with community membership
blockmodel(flomarr.stat,comm.fg$membership)</code></pre>
<pre><code>## 
## Network Blockmodel:
## 
## Block membership:
## 
##  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 
##  1  2  3  3  3  2  2  2  1  1  3  4  1  1  3  1 
## 
## Reduced form blockmodel:
## 
##   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
##            Block 1    Block 2    Block 3 Block 4
## Block 1 0.40000000 0.08333333 0.06666667       0
## Block 2 0.08333333 0.50000000 0.05000000       0
## Block 3 0.06666667 0.05000000 0.60000000       0
## Block 4 0.00000000 0.00000000 0.00000000     NaN</code></pre>
<pre class="r"><code>#only retrieve block density object
blockmodel(flomarr.stat,comm.fg$membership)$block.model</code></pre>
<pre><code>##            Block 1    Block 2    Block 3 Block 4
## Block 1 0.40000000 0.08333333 0.06666667       0
## Block 2 0.08333333 0.50000000 0.05000000       0
## Block 3 0.06666667 0.05000000 0.60000000       0
## Block 4 0.00000000 0.00000000 0.00000000     NaN</code></pre>
<pre class="r"><code>#print block densities using only 2 digits for readability
print(blockmodel(flomarr.stat,comm.fg$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4
## Block 1   0.400   0.083   0.067       0
## Block 2   0.083   0.500   0.050       0
## Block 3   0.067   0.050   0.600       0
## Block 4   0.000   0.000   0.000     NaN</code></pre>
<div id="section-exercise-community-density" class="section level3">
<h3>Exercise: Community density</h3>
<p>Using the same network in the previous step, try using the<code>blockmodel</code> command to print the density of ties within and between community groups. Feel free to use only a single command that produces output you find acceptable (i.e., you only need to use one of the commands from the previous R example syntax.) Do the community clusters work as intended?</p>
<div class="tutorial-exercise" data-label="density" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Inspect density within and between communities</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="density-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Inspect density within and between communities
print(blockmodel(gotmarr.stat,got.fg$membership)$block.model, digits=2)

#alliances
print(blockmodel(alliances.stat, alliances.fg$membership)$block.model, digits=2)
#airport flights
print(blockmodel(airports.fl.stat,airports.fl.fg$membership)$block.model, digits=2)
#airport distance
print(blockmodel(airports.geo.stat, airports.geo.fg$membership)$block.model, digits=2)</code></pre>
</div>
</div>
</div>
<div id="section-adding-community-membership-to-node-info" class="section level2">
<h2>Adding Community Membership to Node Info</h2>
<p>In order to work with the community clusters produced in the initial step, it is convenient to extract the membership vector and add it into our standard <code>network.nodes</code> dataframe. First, let’s inspect the community memberships, comparing the results to the vertex names stored in the object and the results of the <code>membership</code> function.</p>
<pre class="r"><code>#Inspect community membership vector
comm.fg$membership</code></pre>
<pre><code>##  [1] 1 2 3 3 3 2 2 2 1 1 3 4 1 1 3 1</code></pre>
<pre class="r"><code>#Compare to vertex names vector
comm.fg$names</code></pre>
<pre><code>##  [1] &quot;Acciaiuoli&quot;   &quot;Albizzi&quot;      &quot;Barbadori&quot;    &quot;Bischeri&quot;    
##  [5] &quot;Castellani&quot;   &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
##  [9] &quot;Medici&quot;       &quot;Pazzi&quot;        &quot;Peruzzi&quot;      &quot;Pucci&quot;       
## [13] &quot;Ridolfi&quot;      &quot;Salviati&quot;     &quot;Strozzi&quot;      &quot;Tornabuoni&quot;</code></pre>
<pre class="r"><code>#Membership function
membership(comm.fg)</code></pre>
<pre><code>##   Acciaiuoli      Albizzi    Barbadori     Bischeri   Castellani 
##            1            2            3            3            3 
##       Ginori     Guadagni Lamberteschi       Medici        Pazzi 
##            2            2            2            1            1 
##      Peruzzi        Pucci      Ridolfi     Salviati      Strozzi 
##            3            4            1            1            3 
##   Tornabuoni 
##            1</code></pre>
<pre class="r"><code>#Check order of vertex names
V(flomarr.ig)$name</code></pre>
<pre><code>##  [1] &quot;Acciaiuoli&quot;   &quot;Albizzi&quot;      &quot;Barbadori&quot;    &quot;Bischeri&quot;    
##  [5] &quot;Castellani&quot;   &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
##  [9] &quot;Medici&quot;       &quot;Pazzi&quot;        &quot;Peruzzi&quot;      &quot;Pucci&quot;       
## [13] &quot;Ridolfi&quot;      &quot;Salviati&quot;     &quot;Strozzi&quot;      &quot;Tornabuoni&quot;</code></pre>
<p>As can be seen in these results, the <code>membership</code> function provides the information in both the membership and names vector in the original vertex order. Therefore, we can add the information to the <code>flomarr.nodes</code> dataframe and summarize the other node statistics by community.</p>
<pre class="r"><code>#add community membership as a node attribute
flomarr.nodes$comm.fg&lt;-comm.fg$membership
#summarize node statistics by community
flomarr.nodes%&gt;%
  select(-name)%&gt;% group_by(comm.fg)%&gt;%
  mutate(n=n())%&gt;%
  summarise_all(mean, na.rm=TRUE)%&gt;%
  as.matrix()%&gt;%
  print(digits=2)</code></pre>
<pre><code>##      comm.fg degree bonpow betweenness close constraint eigen eigen.rc
## [1,]       1    2.7   0.22        13.2  0.47       0.60  0.24    0.071
## [2,]       2    2.2  -1.04        10.6  0.44       0.65  0.17    0.057
## [3,]       3    3.0  -0.65         6.9  0.48       0.52  0.28    0.082
## [4,]       4    0.0   0.00         0.0  0.00       0.00  0.00      NaN
##      eigen.dc n
## [1,]     0.17 6
## [2,]     0.12 4
## [3,]     0.19 5
## [4,]      NaN 1</code></pre>
<p>Note that here we can tell that there are 6 nodes in community cluster 1, 4 in community cluster 2, 5 nodes in cluster 5, and only 1 node in cluster 4. What other differences do you notice between clusters?</p>
<p>Because we will be repeating the same steps multiple times this week, lets create a custom function to summarize the node statistics by community group.</p>
<pre class="r"><code>nodes.by.gp&lt;-function(network.nodes, groupvar){
  network.nodes%&gt;%
  select(-name)%&gt;%
  group_by_(groupvar) %&gt;%
  mutate(n=n())%&gt;%
  summarise_all(mean, na.rm=TRUE)%&gt;%
  as.matrix()%&gt;%
  print(digits=2)
}</code></pre>
<p>Now, we can use a single command to produce a summary table of node statistics.</p>
<pre class="r"><code>#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.fg&quot;)</code></pre>
<pre><code>##      comm.fg degree bonpow betweenness close constraint eigen eigen.rc
## [1,]       1    2.7   0.22        13.2  0.47       0.60  0.24    0.071
## [2,]       2    2.2  -1.04        10.6  0.44       0.65  0.17    0.057
## [3,]       3    3.0  -0.65         6.9  0.48       0.52  0.28    0.082
## [4,]       4    0.0   0.00         0.0  0.00       0.00  0.00      NaN
##      eigen.dc n
## [1,]     0.17 6
## [2,]     0.12 4
## [3,]     0.19 5
## [4,]      NaN 1</code></pre>
<div id="section-exercise-add-node-info" class="section level3">
<h3>Exercise: Add Node Info</h3>
<p>Try adding on the community membership vector as a node attribute and summarizing node statistics by community. If you have forgotten which nodes belong to each community group, use the command provided in step 1 to retrieve node names.</p>
<div class="tutorial-exercise" data-label="nodeinfo" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="6">
<pre class="text"><code>#add community membership as a node attribute

#summarize node statistics by community

#retrieve list of nodes in each group (if you forgot earlier result)</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="nodeinfo-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#add community membership as a node attribute
gotmarr.nodes$comm.fg&lt;-got.fg$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.fg&quot;)
#retrieve list of nodes in each group
igraph::groups(got.fg)

alliances.nodes$comm.fg&lt;-alliances.fg$membership
nodes.by.gp(alliances.nodes,&quot;comm.fg&quot;)
airports.fl.nodes$comm.fg&lt;-airports.fl.fg$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.fg&quot;)
airports.geo.nodes$comm.fg&lt;-airports.geo.fg$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.fg&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-plot-the-network-with-community-colors" class="section level2">
<h2>Plot the Network with Community Colors</h2>
<p>Igraph has a built-in function to color nodes by community that doesn’t require the researcher to add the membership vector to the network as a vertex attribute. To automatically color nodes by community membership, simply include the <code>community</code> object in the plotting call as follows.</p>
<pre class="r"><code>#plot network with community coloring
plot(comm.fg,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-9-1.png" width="624" /></p>
<div id="section-exercise-plot-network-with-community-coloring" class="section level3">
<h3>Exercise: Plot Network With Community Coloring</h3>
<p>Using the clustering object created in step 1, plot the network with community coloring.</p>
<div class="tutorial-exercise" data-label="plot" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#plot network with community coloring</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="plot-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#plot network with community coloring
plot(got.fg,gotmarr.ig)
plot(alliances.fg,alliances.ig)
plot(airports.fl.fg,airports.fl.ig)
plot(airports.geo.fg,airports.geo.ig)</code></pre>
</div>
</div>
</div>
<div id="section-walktrap-community-detection" class="section level2">
<h2><strong>Walktrap Community Detection</strong></h2>
<p>This algorithm detects communities based on random walks across the network. It can handle a weights argument, which makes it a good tool for weighted networks. Higher weights increase the probability that a random walker goes in that direction vs the direction of a tie with a lower weight.</p>
<pre class="r"><code>#Run clustering algorithm: walktrap
comm.wt&lt;-walktrap.community(flomarr.ig)
#Inspect community membership
igraph::groups(comm.wt)</code></pre>
<pre><code>## $`1`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## 
## $`2`
## [1] &quot;Acciaiuoli&quot; &quot;Medici&quot;     &quot;Ridolfi&quot;    &quot;Tornabuoni&quot;
## 
## $`3`
## [1] &quot;Barbadori&quot;  &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Pazzi&quot;    &quot;Salviati&quot;
## 
## $`5`
## [1] &quot;Pucci&quot;</code></pre>
<p>The critical parameter for the walktrap method is <code>steps=x</code>, and the value of <span class="math inline">\(x\)</span> can result in different community membership vectors (and also affect how long the algorithm takes to run). Let’s try with more steps. Do you have any ideas about what might be going on when we increase the number of steps?</p>
<pre class="r"><code>#Run &amp; inspect clustering algorithm: 10 steps
igraph::groups(walktrap.community(flomarr.ig, steps=10))</code></pre>
<pre><code>## $`1`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## 
## $`2`
## [1] &quot;Acciaiuoli&quot; &quot;Medici&quot;     &quot;Ridolfi&quot;    &quot;Tornabuoni&quot;
## 
## $`3`
## [1] &quot;Barbadori&quot;  &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Pazzi&quot;    &quot;Salviati&quot;
## 
## $`5`
## [1] &quot;Pucci&quot;</code></pre>
<pre class="r"><code>#Run &amp; inspect clustering algorithm: 20 steps
igraph::groups(walktrap.community(flomarr.ig ,steps=20))</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot;   &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;    
## [5] &quot;Lamberteschi&quot; &quot;Medici&quot;       &quot;Ridolfi&quot;      &quot;Tornabuoni&quot;  
## 
## $`2`
## [1] &quot;Barbadori&quot;  &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`3`
## [1] &quot;Pazzi&quot;    &quot;Salviati&quot;
## 
## $`4`
## [1] &quot;Pucci&quot;</code></pre>
<pre class="r"><code>#Run &amp; inspect clustering algorithm
igraph::groups(walktrap.community(flomarr.ig, steps=100))</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot; &quot;Albizzi&quot;    &quot;Barbadori&quot;  &quot;Ginori&quot;     &quot;Medici&quot;    
## [6] &quot;Ridolfi&quot;    &quot;Tornabuoni&quot;
## 
## $`2`
## [1] &quot;Pazzi&quot;    &quot;Salviati&quot;
## 
## $`3`
## [1] &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## 
## $`5`
## [1] &quot;Pucci&quot;</code></pre>
<p>The community object can be used in the various steps introduced earlier. Lets inspect density of ties within and between communities, and the characteristics of nodes in each community.</p>
<pre class="r"><code>#inspect density of between/within community ties
print(blockmodel(flomarr.stat,comm.wt$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4 Block 5
## Block 1    0.50    0.12    0.05    0.00       0
## Block 2    0.12    0.67    0.10    0.12       0
## Block 3    0.05    0.10    0.60    0.00       0
## Block 4    0.00    0.12    0.00    1.00       0
## Block 5    0.00    0.00    0.00    0.00     NaN</code></pre>
<pre class="r"><code>#add community membership as a vertex attribute
flomarr.nodes$comm.wt&lt;-comm.wt$membership
#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.wt&quot;)</code></pre>
<pre><code>##      comm.wt degree bonpow betweenness close constraint eigen eigen.rc
## [1,]       1    2.2 -1.044        10.6  0.44       0.65 0.174    0.057
## [2,]       2    3.2  0.380        16.5  0.52       0.53 0.307    0.090
## [3,]       3    3.0 -0.645         6.9  0.48       0.52 0.277    0.082
## [4,]       4    1.5 -0.095         6.5  0.38       0.75 0.095    0.032
## [5,]       5    0.0  0.000         0.0  0.00       0.00 0.000      NaN
##      eigen.dc comm.fg n
## [1,]    0.117       2 4
## [2,]    0.217       1 4
## [3,]    0.195       3 5
## [4,]    0.063       1 2
## [5,]      NaN       4 1</code></pre>
<p>Finally, lets try plotting the network with walktrap community coloring.</p>
<pre class="r"><code>#plot network with community coloring
plot(comm.wt,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-13-1.png" width="624" /></p>
<div id="section-exercise-walk-trap" class="section level3">
<h3>Exercise: Walk Trap</h3>
<p>Repeat all of the above steps for one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="walktrap" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: walktrap

#Inspect community membership

#Optional: Experiment with steps option

#inspect density of between/within community ties

#add community membership as a vertex attribute

#summarize node statistics by community

#plot the network with community coloring</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="walktrap-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: walktrap
got.wt&lt;-walktrap.community(gotmarr.ig)
#Inspect community membership
igraph::groups(got.wt)
#inspect density of between/within community ties
print(blockmodel(gotmarr.stat,got.wt$membership)$block.model, digits=2)
#add community membership as a vertex attribute
gotmarr.nodes$comm.wt&lt;-got.wt$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.wt&quot;)
#plot the network with community coloring
plot(got.wt,gotmarr.ig)

alliances.wt&lt;-walktrap.community(alliances.ig)
igraph::groups(alliances.wt)
print(blockmodel(alliances.stat,alliances.wt$membership)$block.model, digits=2)
alliances.nodes$comm.wt&lt;-alliances.wt$membership
nodes.by.gp(alliances.nodes,&quot;comm.wt&quot;)
plot(alliances.wt,alliances.ig)

airports.fl.wt&lt;-walktrap.community(airports.fl.ig)
print(blockmodel(airports.fl.stat,airports.fl.wt$membership)$block.model, digits=2)
airports.fl.nodes$comm.wt&lt;-airports.fl.wt$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.wt&quot;)
plot(airports.fl.wt,airports.fl.ig)

airports.geo.wt&lt;-walktrap.community(airports.geo.ig)
print(blockmodel(airports.geo.stat,airports.geo.wt$membership)$block.model, digits=2)
airports.geo.nodes$comm.wt&lt;-airports.geo.wt$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.wt&quot;)
plot(airports.geo.wt,airports.geo.ig)</code></pre>
</div>
</div>
</div>
<div id="section-compare-community-partitions" class="section level2">
<h2>Compare Community Partitions</h2>
<p>How different are the community clusters that were created using this method? It is possible to manually compare the block densities within and between the community groups, compare the average node statistics in the resulting communities, or visually inspect the colored network plots. One alternative approach is to directly compare the modularity index produced by each partition.</p>
<pre class="r"><code>#compare community partition modularity scores
modularity(comm.fg)</code></pre>
<pre><code>## [1] 0.4410431</code></pre>
<pre class="r"><code>modularity(comm.wt)</code></pre>
<pre><code>## [1] 0.3922902</code></pre>
<p>As expected, the partition produced by the fast, greedy algorithm is characterized by a higher modularity score than the one produced by the walktrap algorithm. This is expected because the goal of fast, greedy is to optimize modularity. But would you agree that the resulting partition is necessariy superior to the community partiton produced by walktrap?</p>
<p>One thing to notice is that as we compare additional algorithms, it will be easier to simply add each new modularity score to a list and return that list for comparison, rather than cutting and pasting the code to recover each individual modularity index each time. To do this, we will use <code>c()</code> to create a new list, called <em>mods</em>, and will add to this list with each algorithm.</p>
<pre class="r"><code>#collect modularity scores to compare
mods&lt;-c(fastgreedy=modularity(comm.fg), walktrap=modularity(comm.wt))
mods</code></pre>
<pre><code>## fastgreedy   walktrap 
##  0.4410431  0.3922902</code></pre>
<p>Another approach is to use the <code>compare</code> function which provides several different methods for comparing the network partitions: <code>&quot;vi&quot;, &quot;nmi&quot;, &quot;split.join&quot;, &quot;rand&quot;, &quot;adjusted.rand&quot;</code>. For a relatively accessible (but still sort of challenging) overview of the different approaches to comparing network partitions, <a href="https://publikationen.bibliothek.kit.edu/1000011477/812079">see this article.</a></p>
<p>Differences between two partitions can be calculated using the two entropy-based information measures <em>vi</em> and <em>nmi</em>, plus <em>split.join</em>. <em>nmi</em> varies between 0 and 1, while <em>vi</em> has a much higher upper bound than <em>nmi</em>. <em>split.join</em> is also a distance based measure, capturing the projection distance between the two partitions - or intuitively how many moves (like a Rubiks Cube) are required to go from one partition to another. It returns two values (as the distance from partition A to partition B is not necessariy the same as the distance from partition B to partition A.) Higher numbers on <em>split.join</em> mean that two partitions are less similar to (or more distant from) each other. <em>vi</em> is more affected by the number of community groups than <em>slit.join</em>.</p>
<p>Both Rand index measures vary between 0 and 1, and indicate the proportion of times that the two partitioning methods agree that two nodes belong in the same community, with the <em>adjusted</em> version also taking into account the possibility of random variation in clustering. For now, lets see the results of all 5 methods.</p>
<pre class="r"><code>#compare community partitions using variation of information
compare(comm.fg,comm.wt,method=&quot;vi&quot;)</code></pre>
<pre><code>## [1] 0.2386928</code></pre>
<pre class="r"><code>#compare community partitions using normalized mutual information
compare(comm.fg,comm.wt,method=&quot;nmi&quot;)</code></pre>
<pre><code>## [1] 0.9129178</code></pre>
<pre class="r"><code>#compare community partitions using split join distance
compare(comm.fg,comm.wt,method=&quot;split.join&quot;)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>#compare community partitions using Rand index
compare(comm.fg,comm.wt,method=&quot;rand&quot;)</code></pre>
<pre><code>## [1] 0.9333333</code></pre>
<pre class="r"><code>#compare community partitions using adjusted Rand index
compare(comm.fg,comm.wt,method=&quot;adjusted.rand&quot;)</code></pre>
<pre><code>## [1] 0.8100514</code></pre>
<p>One thing to notice comparing the two Rand index measures is that the adjusted one is much lower than the standard measure not adjusted for random variation in clustering. The two partitions appear to be fairly similar based on the Rand index, but less so once random variation is taken into account. In and of itself, the comparison scores don’t tell us which method is better - but they do provide a sense of how similar the partitions produced by two methods are - and thus can be useful when comparing the results of a specific partitioning approach to a gold standard partition.</p>
<p>Finally, note that once again, the code in the previous R snippet will start to grow much longer as we try to compare additional community partition algorithms. An alternative is to use a custom function that uses <code>expand.grid</code> in combination with a <code>for()</code> loop to quickly cycle through multiple combinations and calculate the comparative metrics.</p>
<pre class="r"><code>compare.algs&lt;-function(alg.a,alg.b,compare.meth=c(&quot;vi&quot;, &quot;nmi&quot;, &quot;split.join&quot;, &quot;rand&quot;, &quot;adjusted.rand&quot;)){
  #create list of community objects and methods
  comm.compare&lt;-expand.grid(alg.a=alg.a, alg.b=alg.b, meth=compare.meth, result=NA, stringsAsFactors = FALSE)
  #compare community partitions using a loop
for(i in 1:nrow(comm.compare)){
  comm1&lt;-get(comm.compare$alg.a[i])
  comm2&lt;-get(comm.compare$alg.b[i])
  method&lt;-comm.compare$meth[i]
  comm.compare$result[i]&lt;-compare(comm1, comm2, method)
}
  return(comm.compare)
}</code></pre>
<p>Once the <code>compare.algs()</code> function is set up, all you need to do is provide it with a vector of the community object names (alg.a) that you wish to compare to the baseline community partition (alg.b). Note that you can decide which methods to use to compare partitions. By default, the <code>compare.algs</code> function currently returns all 5 available metrics.</p>
<pre class="r"><code>#compare community partitions
compare.algs(alg.a=c(&quot;comm.fg&quot;),alg.b=&quot;comm.wt&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["alg.a"],"name":[1],"type":["chr"],"align":["left"]},{"label":["alg.b"],"name":[2],"type":["chr"],"align":["left"]},{"label":["meth"],"name":[3],"type":["chr"],"align":["left"]},{"label":["result"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"comm.fg","2":"comm.wt","3":"vi","4":"0.2386928"},{"1":"comm.fg","2":"comm.wt","3":"nmi","4":"0.9129178"},{"1":"comm.fg","2":"comm.wt","3":"split.join","4":"2.0000000"},{"1":"comm.fg","2":"comm.wt","3":"rand","4":"0.9333333"},{"1":"comm.fg","2":"comm.wt","3":"adjusted.rand","4":"0.8100514"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="section-exercise-compare-two-partitions" class="section level3">
<h3>Exercise: Compare two partitions</h3>
<p>Compare the fast, greedy partition to the walktrap partition you created using your chosen network. How similar are the two partitions, particularly in comparison to the similarity that we observed in the community partitions of the Florentine marriage network or some other network you have inspected?</p>
<div class="tutorial-exercise" data-label="compare" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#collect modularity scores to compare

#compare community partitions</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="compare-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#collect modularity scores to compare
mods&lt;-c(fastgreedy=modularity(got.fg), walktrap=modularity(got.wt))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;got.fg&quot;),alg.b=&quot;got.wt&quot;)

#alliances
alliances.mods&lt;-c(fastgreedy=modularity(alliances.fg), walktrap=modularity(alliances.wt))
alliances.mods
#compare community partitions
compare.algs(alg.a=c(&quot;alliances.fg&quot;),alg.b=&quot;alliances.wt&quot;)

#airports.flights
mods&lt;-c(fastgreedy=modularity(airports.fl.fg), walktrap=modularity(airports.fl.wt))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;airports.fl.fg&quot;),alg.b=&quot;airports.fl.wt&quot;)

#airports.geograph
mods&lt;-c(fastgreedy=modularity(airports.geo.fg), walktrap=modularity(airports.geo.wt))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;airports.geo.fg&quot;),alg.b=&quot;airports.geo.wt&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-leading-label-propagation-community-detection" class="section level2">
<h2><strong>Leading Label Propagation Community Detection</strong></h2>
<p>Label propogation is a fast algorithm that uses neighborhood voting to find communities. It can used weighted networks if you have a <code>weight</code> edge attribute or use the options <code>weights=</code>.</p>
<pre class="r"><code>#Run clustering algorithm: leading label
comm.lab&lt;-label.propagation.community(flomarr.ig)
#Inspect community membership
igraph::groups(comm.lab)</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot; &quot;Albizzi&quot;    &quot;Barbadori&quot;  &quot;Ginori&quot;     &quot;Medici&quot;    
## [6] &quot;Pazzi&quot;      &quot;Salviati&quot;  
## 
## $`2`
## [1] &quot;Bischeri&quot;     &quot;Castellani&quot;   &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## [5] &quot;Peruzzi&quot;      &quot;Ridolfi&quot;      &quot;Strozzi&quot;      &quot;Tornabuoni&quot;  
## 
## $`3`
## [1] &quot;Pucci&quot;</code></pre>
<p>We can describe and plot the label propagation communities.</p>
<pre class="r"><code>#inspect density of between/within community ties
print(blockmodel(flomarr.stat,comm.lab$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3
## Block 1   0.286   0.071       0
## Block 2   0.071   0.357       0
## Block 3   0.000   0.000     NaN</code></pre>
<pre class="r"><code>#add community membership as a vertex attribute
flomarr.nodes$comm.lab&lt;-comm.lab$membership
#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.lab&quot;)</code></pre>
<pre><code>##      comm.lab degree bonpow betweenness close constraint eigen eigen.rc
## [1,]        1    2.3 -0.949        12.6  0.45       0.65  0.18    0.058
## [2,]        2    3.0  0.071         8.5  0.48       0.53  0.28    0.082
## [3,]        3    0.0  0.000         0.0  0.00       0.00  0.00      NaN
##      eigen.dc comm.fg comm.wt n
## [1,]     0.12     1.6     2.4 7
## [2,]     0.20     2.2     2.2 8
## [3,]      NaN     4.0     5.0 1</code></pre>
<pre class="r"><code>#plot network with community coloring
plot(comm.lab,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-20-1.png" width="624" /></p>
<p>Finally, lets compare the different community partitions. Note that you can use the <code>c()</code> function to just add a new item, the modularity index of our new community partition, to the vector of modularity scores, <em>mods</em>. Similarly, we just add the two previous algorithms to the <em>alg.a</em> vector, and then set the new algorithm to be <em>alg.b</em>.</p>
<pre class="r"><code>#collect modularity scores to compare
mods&lt;-c(mods, label=modularity(comm.lab))
mods</code></pre>
<pre><code>## fastgreedy   walktrap      label 
##  0.4410431  0.3922902  0.3356009</code></pre>
<pre class="r"><code>#compare community partitions
compare.algs(alg.a=c(&quot;comm.fg&quot;,&quot;comm.wt&quot;),alg.b=&quot;comm.lab&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["alg.a"],"name":[1],"type":["chr"],"align":["left"]},{"label":["alg.b"],"name":[2],"type":["chr"],"align":["left"]},{"label":["meth"],"name":[3],"type":["chr"],"align":["left"]},{"label":["result"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"comm.fg","2":"comm.lab","3":"vi","4":"1.50633445"},{"1":"comm.wt","2":"comm.lab","3":"vi","4":"1.61421523"},{"1":"comm.fg","2":"comm.lab","3":"nmi","4":"0.29369215"},{"1":"comm.wt","2":"comm.lab","3":"nmi","4":"0.31929319"},{"1":"comm.fg","2":"comm.lab","3":"split.join","4":"12.00000000"},{"1":"comm.wt","2":"comm.lab","3":"split.join","4":"14.00000000"},{"1":"comm.fg","2":"comm.lab","3":"rand","4":"0.58333333"},{"1":"comm.wt","2":"comm.lab","3":"rand","4":"0.58333333"},{"1":"comm.fg","2":"comm.lab","3":"adjusted.rand","4":"0.08564462"},{"1":"comm.wt","2":"comm.lab","3":"adjusted.rand","4":"0.06044472"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="section-exercise-leading-label-propagation" class="section level3">
<h3>Exercise: Leading Label Propagation</h3>
<p>Repeat the basic community analysis routine for one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="labprop" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: leading label

#Inspect community membership

#inspect density of between/within community ties

#add community membership as a vertex attribute

#summarize node statistics by community

#plot the network with community coloring

#collect modularity scores to compare

#compare community partitions</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="labprop-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: leading label
got.lab&lt;-walktrap.community(gotmarr.ig)
#Inspect community membership
igraph::groups(got.lab)
#inspect density of between/within community ties
print(blockmodel(gotmarr.stat,got.lab$membership)$block.model, digits=2)
#add community membership as a vertex attribute
gotmarr.nodes$comm.lab&lt;-got.lab$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.lab&quot;)
#plot the network with community coloring
plot(got.lab,gotmarr.ig)
#collect modularity scores to compare
mods&lt;-c(mods, label=modularity(comm.lab))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;got.fg&quot;,&quot;got.wt&quot;),alg.b=&quot;got.lab&quot;)

#alliances
alliances.lab&lt;-walktrap.community(alliances.ig)
igraph::groups(alliances.lab)
print(blockmodel(alliances.stat,alliances.lab$membership)$block.model, digits=2)
alliances.nodes$comm.lab&lt;-alliances.lab$membership
nodes.by.gp(alliances.nodes,&quot;comm.lab&quot;)
plot(alliances.lab,alliances.ig)
mods&lt;-c(mods, label=modularity(comm.lab))
mods
compare.algs(alg.a=c(&quot;alliances.fg&quot;,&quot;alliances.wt&quot;),alg.b=&quot;alliances.lab&quot;)

#airport flights
airports.fl.lab&lt;-walktrap.community(airports.fl.ig)
igraph::groups(airports.fl.lab)
print(blockmodel(airports.fl.stat,airports.fl.lab$membership)$block.model, digits=2)
airports.fl.nodes$comm.lab&lt;-airports.fl.lab$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.lab&quot;)
plot(airports.fl.lab,airports.fl.ig)
mods&lt;-c(mods, label=modularity(comm.lab))
mods
compare.algs(alg.a=c(&quot;airports.fl.fg&quot;,&quot;airports.fl.wt&quot;),alg.b=&quot;airports.fl.lab&quot;)

#airport geography
airports.geo.lab&lt;-walktrap.community(airports.geo.ig)
igraph::groups(airports.geo.lab)
print(blockmodel(airports.geo.stat,airports.geo.lab$membership)$block.model, digits=2)
airports.geo.nodes$comm.lab&lt;-airports.geo.lab$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.lab&quot;)
plot(airports.geo.lab,airports.geo.ig)
mods&lt;-c(mods, label=modularity(comm.lab))
mods
compare.algs(alg.a=c(&quot;airports.geo.fg&quot;,&quot;airports.geo.wt&quot;),alg.b=&quot;airports.geo.lab&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-edge-betweenness-community-detection" class="section level2">
<h2><strong>Edge Betweenness Community Detection</strong></h2>
<p>Edge betweenness looks for communities with sparse connections between them and works by eliminating high betweenness nodes. It can used weighted networks if you have a <code>weight</code> edge attribute or use the options <code>weights=</code>. The algorithm automatically adjusts betweenness scores for directed networks, although this can be adjusted by setting the option <code>directed=FALSE</code>.</p>
<pre class="r"><code>#Run clustering algorithm: edge betweenness
comm.edge&lt;-label.propagation.community(flomarr.ig)
#Inspect community membership
igraph::groups(comm.edge)</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot; &quot;Barbadori&quot;  &quot;Medici&quot;     &quot;Pazzi&quot;      &quot;Ridolfi&quot;   
## [6] &quot;Salviati&quot;   &quot;Tornabuoni&quot;
## 
## $`2`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## 
## $`3`
## [1] &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Pucci&quot;</code></pre>
<p>We can describe and plot the edge betweenness communities.</p>
<pre class="r"><code>#inspect density of between/within community ties
print(blockmodel(flomarr.stat,comm.edge$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4
## Block 1   0.333   0.071   0.071       0
## Block 2   0.071   0.500   0.062       0
## Block 3   0.071   0.062   0.833       0
## Block 4   0.000   0.000   0.000     NaN</code></pre>
<pre class="r"><code>#add community membership as a vertex attribute
flomarr.nodes$comm.edge&lt;-comm.edge$membership
#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.edge&quot;)</code></pre>
<pre><code>##      comm.edge degree bonpow betweenness close constraint eigen eigen.rc
## [1,]         1    2.6 -0.027        12.5  0.47       0.59  0.23    0.067
## [2,]         2    2.2 -1.044        10.6  0.44       0.65  0.17    0.057
## [3,]         3    3.2 -0.427         6.5  0.48       0.52  0.29    0.091
## [4,]         4    0.0  0.000         0.0  0.00       0.00  0.00      NaN
##      eigen.dc comm.fg comm.wt comm.lab n
## [1,]     0.17     1.3     2.7      1.3 7
## [2,]     0.12     2.0     1.0      1.5 4
## [3,]     0.20     3.0     3.0      2.0 4
## [4,]      NaN     4.0     5.0      3.0 1</code></pre>
<pre class="r"><code>#plot network with community coloring
plot(comm.edge,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-23-1.png" width="624" /></p>
<p>Compare the various community partitions created so far by adding to the modularity index vector and using our custom function.</p>
<pre class="r"><code>#collect modularity scores to compare
mods&lt;-c(mods, edge=modularity(comm.edge))
mods</code></pre>
<pre><code>## fastgreedy   walktrap      label       edge 
##  0.4410431  0.3922902  0.3356009  0.4342404</code></pre>
<pre class="r"><code>#compare community partitions
compare.algs(alg.a=c(&quot;comm.fg&quot;,&quot;comm.wt&quot;, &quot;comm.lab&quot;), alg.b=&quot;comm.edge&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["alg.a"],"name":[1],"type":["chr"],"align":["left"]},{"label":["alg.b"],"name":[2],"type":["chr"],"align":["left"]},{"label":["meth"],"name":[3],"type":["chr"],"align":["left"]},{"label":["result"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"comm.fg","2":"comm.edge","3":"vi","4":"0.3358016"},{"1":"comm.wt","2":"comm.edge","3":"vi","4":"0.5744945"},{"1":"comm.lab","2":"comm.edge","3":"vi","4":"1.2166331"},{"1":"comm.fg","2":"comm.edge","3":"nmi","4":"0.8645558"},{"1":"comm.wt","2":"comm.edge","3":"nmi","4":"0.7886299"},{"1":"comm.lab","2":"comm.edge","3":"nmi","4":"0.4232977"},{"1":"comm.fg","2":"comm.edge","3":"split.join","4":"2.0000000"},{"1":"comm.wt","2":"comm.edge","3":"split.join","4":"4.0000000"},{"1":"comm.lab","2":"comm.edge","3":"split.join","4":"10.0000000"},{"1":"comm.fg","2":"comm.edge","3":"rand","4":"0.9166667"},{"1":"comm.wt","2":"comm.edge","3":"rand","4":"0.8500000"},{"1":"comm.lab","2":"comm.edge","3":"rand","4":"0.6333333"},{"1":"comm.fg","2":"comm.edge","3":"adjusted.rand","4":"0.7870075"},{"1":"comm.wt","2":"comm.edge","3":"adjusted.rand","4":"0.5847751"},{"1":"comm.lab","2":"comm.edge","3":"adjusted.rand","4":"0.2007266"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="section-exercise-edge-betweenness" class="section level3">
<h3>Exercise: Edge Betweenness</h3>
<p>Repeat the basic community analysis routine for one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="between" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: edge betweenness

#Inspect community membership

#inspect density of between/within community ties

#add community membership as a vertex attribute

#summarize node statistics by community

#plot the network with community coloring

#compare modularity scores

#compare community partitions</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="between-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: edge betweenness
got.edge&lt;-edge.betweenness.community(gotmarr.ig)
#Inspect community membership
igraph::groups(got.edge)
#inspect density of between/within community ties
print(blockmodel(gotmarr.stat,got.edge$membership)$block.model, digits=2)
#add community membership as a vertex attribute
gotmarr.nodes$comm.edge&lt;-got.edge$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.edge&quot;)
#plot the network with community coloring
plot(got.edge,gotmarr.ig)
#collect modularity scores to compare
mods&lt;-c(mods, edge=modularity(comm.edge))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;got.fg&quot;,&quot;got.wt&quot;, &quot;got.lab&quot;),alg.b=&quot;got.edge&quot;)

#alliances
alliances.edge&lt;-edge.betweenness.community(alliances.ig)
igraph::groups(alliances.edge)
print(blockmodel(alliances.stat,alliances.edge$membership)$block.model, digits=2)
alliances.nodes$comm.edge&lt;-alliances.edge$membership
nodes.by.gp(alliances.nodes,&quot;comm.edge&quot;)
plot(alliances.edge,alliances.ig)
mods&lt;-c(mods, edge=modularity(comm.edge))
mods
compare.algs(alg.a=c(&quot;alliances.fg&quot;,&quot;alliances.wt&quot;, &quot;alliances.lab&quot;), alg.b=&quot;alliances.edge&quot;)

#airport flights
airports.fl.edge&lt;-edge.betweenness.community(airports.fl.ig)
igraph::groups(airports.fl.edge)
print(blockmodel(airports.fl.stat,airports.fl.edge$membership)$block.model, digits=2)
airports.fl.nodes$comm.edge&lt;-airports.fl.edge$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.edge&quot;)
plot(airports.fl.edge,airports.fl.ig)
mods&lt;-c(mods, edge=modularity(comm.edge))
mods
compare.algs(alg.a=c(&quot;airports.fl.fg&quot;,&quot;airports.fl.wt&quot;, &quot;airports.fl.lab&quot;), alg.b=&quot;airports.fl.edge&quot;)

#airport geography
airports.geo.edge&lt;-edge.betweenness.community(airports.geo.ig)
igraph::groups(airports.geo.edge)
print(blockmodel(airports.geo.stat,airports.geo.edge$membership)$block.model, digits=2)
airports.geo.nodes$comm.edge&lt;-airports.geo.edge$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.edge&quot;)
plot(airports.geo.edge,airports.geo.ig)
mods&lt;-c(mods, edge=modularity(comm.edge))
mods
compare.algs(alg.a=c(&quot;airports.geo.fg&quot;,&quot;airports.geo.wt&quot;, &quot;airports.geo.lab&quot;), alg.b=&quot;airports.geo.edge&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-eigenvector-community-detection" class="section level2">
<h2><strong>Eigenvector Community Detection</strong></h2>
<p>The leading eigenvector community detection method is based on the eigenvectors of the modularity matrix of the network. It has a few options such as <code>steps</code> and <code>start</code> that might be useful, but are not typically used. A weighted network can be used with the standards <code>weights</code> opton or an appropriately named “weights” edge attribute.</p>
<pre class="r"><code>#Run clustering algorithm: leading eigenvector
comm.eigen&lt;-leading.eigenvector.community(flomarr.ig)
#Inspect community membership
igraph::groups(comm.eigen)</code></pre>
<pre><code>## $`1`
## [1] &quot;Acciaiuoli&quot; &quot;Barbadori&quot;  &quot;Medici&quot;     &quot;Pazzi&quot;      &quot;Ridolfi&quot;   
## [6] &quot;Salviati&quot;  
## 
## $`2`
## [1] &quot;Pucci&quot;
## 
## $`3`
## [1] &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`4`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;
## [5] &quot;Tornabuoni&quot;</code></pre>
<p>We can describe and plot the leading eigenvector communities.</p>
<pre class="r"><code>#inspect density of between/within community ties
print(blockmodel(flomarr.stat,comm.eigen$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4
## Block 1   0.333       0   0.083    0.10
## Block 2   0.000     NaN   0.000    0.00
## Block 3   0.083       0   0.833    0.05
## Block 4   0.100       0   0.050    0.40</code></pre>
<pre class="r"><code>#add community membership as a vertex attribute
flomarr.nodes$comm.eigen&lt;-comm.eigen$membership
#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.eigen&quot;)</code></pre>
<pre><code>##      comm.eigen degree bonpow betweenness close constraint eigen eigen.rc
## [1,]          1    2.5  -0.22        13.2  0.46       0.61  0.22    0.066
## [2,]          2    0.0   0.00         0.0  0.00       0.00  0.00      NaN
## [3,]          3    3.2  -0.43         6.5  0.48       0.52  0.29    0.091
## [4,]          4    2.4  -0.61        10.2  0.46       0.61  0.20    0.061
##      eigen.dc comm.fg comm.wt comm.lab comm.edge n
## [1,]     0.15     1.3     2.8      1.2       1.0 6
## [2,]      NaN     4.0     5.0      3.0       4.0 1
## [3,]     0.20     3.0     3.0      2.0       3.0 4
## [4,]     0.14     1.8     1.2      1.6       1.8 5</code></pre>
<pre class="r"><code>#plot network with community coloring
plot(comm.eigen,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-26-1.png" width="624" /></p>
<p>Compare the various community partitions created so far by adding to the modularity index and using our custom function.</p>
<pre class="r"><code>#collect modularity scores to compare
mods&lt;-c(mods, eigen=modularity(comm.eigen))
mods</code></pre>
<pre><code>## fastgreedy   walktrap      label       edge      eigen 
##  0.4410431  0.3922902  0.3356009  0.4342404  0.4070295</code></pre>
<pre class="r"><code>#compare community partitions
compare.algs(alg.a=c(&quot;comm.fg&quot;,&quot;comm.wt&quot;, &quot;comm.lab&quot;, &quot;comm.edge&quot;), alg.b=&quot;comm.eigen&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["alg.a"],"name":[1],"type":["chr"],"align":["left"]},{"label":["alg.b"],"name":[2],"type":["chr"],"align":["left"]},{"label":["meth"],"name":[3],"type":["chr"],"align":["left"]},{"label":["result"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"comm.fg","2":"comm.eigen","3":"vi","4":"0.6506724"},{"1":"comm.wt","2":"comm.eigen","3":"vi","4":"0.8326119"},{"1":"comm.lab","2":"comm.eigen","3":"vi","4":"1.1281769"},{"1":"comm.edge","2":"comm.eigen","3":"vi","4":"0.3358016"},{"1":"comm.fg","2":"comm.eigen","3":"nmi","4":"0.7399715"},{"1":"comm.wt","2":"comm.eigen","3":"nmi","4":"0.6962384"},{"1":"comm.lab","2":"comm.eigen","3":"nmi","4":"0.4710071"},{"1":"comm.edge","2":"comm.eigen","3":"nmi","4":"0.8645558"},{"1":"comm.fg","2":"comm.eigen","3":"split.join","4":"4.0000000"},{"1":"comm.wt","2":"comm.eigen","3":"split.join","4":"6.0000000"},{"1":"comm.lab","2":"comm.eigen","3":"split.join","4":"9.0000000"},{"1":"comm.edge","2":"comm.eigen","3":"split.join","4":"2.0000000"},{"1":"comm.fg","2":"comm.eigen","3":"rand","4":"0.8500000"},{"1":"comm.wt","2":"comm.eigen","3":"rand","4":"0.8166667"},{"1":"comm.lab","2":"comm.eigen","3":"rand","4":"0.6666667"},{"1":"comm.edge","2":"comm.eigen","3":"rand","4":"0.9166667"},{"1":"comm.fg","2":"comm.eigen","3":"adjusted.rand","4":"0.6085538"},{"1":"comm.wt","2":"comm.eigen","3":"adjusted.rand","4":"0.4776415"},{"1":"comm.lab","2":"comm.eigen","3":"adjusted.rand","4":"0.2685157"},{"1":"comm.edge","2":"comm.eigen","3":"adjusted.rand","4":"0.7870075"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div id="section-exercise-eigenvector-communities" class="section level3">
<h3>Exercise: Eigenvector Communities</h3>
<p>Repeat the basic community analysis routine for one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="eigen" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: leading eigenvector

#Inspect community membership

#inspect density of between/within community ties

#add community membership as a vertex attribute

#summarize node statistics by community

#plot the network with community coloring

#compare modularity scores

#compare community partitions</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="eigen-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: leading eigenvector
got.eigen&lt;-leading.eigenvector.community(gotmarr.ig)
#Inspect community membership
igraph::groups(got.eigen)
#inspect density of between/within community ties
print(blockmodel(gotmarr.stat,got.eigen$membership)$block.model, digits=2)
#add community membership as a vertex attribute
gotmarr.nodes$comm.eigen&lt;-got.eigen$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.eigen&quot;)
#plot the network with community coloring
plot(got.eigen,gotmarr.ig)
#collect modularity scores to compare
mods&lt;-c(mods, eigen=modularity(comm.eigen))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;got.fg&quot;,&quot;got.wt&quot;, &quot;got.lab&quot;, &quot;got.edge&quot;), alg.b=&quot;got.eigen&quot;)

#alliances
alliances.eigen&lt;-leading.eigenvector.community(alliances.ig)
igraph::groups(alliances.eigen)
print(blockmodel(alliances.stat,alliances.eigen$membership)$block.model, digits=2)
alliances.nodes$comm.eigen&lt;-alliances.eigen$membership
nodes.by.gp(alliances.nodes,&quot;comm.eigen&quot;)
plot(alliances.eigen,alliances.ig)
mods&lt;-c(mods, eigen=modularity(comm.eigen))
mods
compare.algs(alg.a=c(&quot;alliances.fg&quot;,&quot;alliances.wt&quot;, &quot;alliances.lab&quot;, &quot;alliances.edge&quot;), alg.b=&quot;alliances.eigen&quot;)

#airport flights
airports.fl.eigen&lt;-leading.eigenvector.community(airports.fl.ig)
igraph::groups(airports.fl.eigen)
print(blockmodel(airports.fl.stat,airports.fl.eigen$membership)$block.model, digits=2)
airports.fl.nodes$comm.eigen&lt;-airports.fl.eigen$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.eigen&quot;)
plot(airports.fl.eigen,airports.fl.ig)
mods&lt;-c(mods, eigen=modularity(comm.eigen))
mods
compare.algs(alg.a=c(&quot;airports.fl.fg&quot;,&quot;airports.fl.wt&quot;, &quot;airports.fl.lab&quot;, &quot;airports.fl.edge&quot;), alg.b=&quot;airports.fl.eigen&quot;)

#airport geography
airports.geo.eigen&lt;-leading.eigenvector.community(airports.geo.ig)
igraph::groups(airports.geo.eigen)
print(blockmodel(airports.geo.stat,airports.geo.eigen$membership)$block.model, digits=2)
airports.geo.nodes$comm.eigen&lt;-airports.geo.eigen$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.eigen&quot;)
plot(airports.geo.eigen,airports.geo.ig)
mods&lt;-c(mods, eigen=modularity(comm.eigen))
mods
compare.algs(alg.a=c(&quot;airports.geo.fg&quot;,&quot;airports.geo.wt&quot;, &quot;airports.geo.lab&quot;, &quot;airports.geo.edge&quot;), alg.b=&quot;airports.geo.eigen&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-spinglass-community-detection" class="section level2">
<h2><strong>Spinglass Community Detection</strong></h2>
<p>If we ran this algoritm on our entire network, we would get an error. This algorithm doesn’t work with a disconnected graphs! Let’s run it on a connected component subgraph. We first need to create a custom function to extract the giant component.</p>
<pre class="r"><code>giant.component &lt;- function(graph) {
  cl &lt;- clusters(graph)
  induced.subgraph(graph, which(cl$membership == which.max(cl$csize)))
}</code></pre>
<pre class="r"><code>#extract giant component
flomarr.giant&lt;-giant.component(flomarr.ig)</code></pre>
<pre class="r"><code>#Run clustering algorithm: spinglass
comm.spin&lt;-spinglass.community(flomarr.giant)
#Inspect community membership
igraph::groups(comm.spin)</code></pre>
<pre><code>## $`1`
## [1] &quot;Pazzi&quot;    &quot;Salviati&quot;
## 
## $`2`
## [1] &quot;Bischeri&quot;   &quot;Castellani&quot; &quot;Peruzzi&quot;    &quot;Strozzi&quot;   
## 
## $`3`
## [1] &quot;Acciaiuoli&quot; &quot;Barbadori&quot;  &quot;Medici&quot;     &quot;Ridolfi&quot;    &quot;Tornabuoni&quot;
## 
## $`4`
## [1] &quot;Albizzi&quot;      &quot;Ginori&quot;       &quot;Guadagni&quot;     &quot;Lamberteschi&quot;</code></pre>
<p>We can describe and plot the spinglass communities. Note the changes to the line adding community membership as a vertex attribute. The <code>which()</code> statement omits the nodes that are not part of the giant component when matching the community membership vector. Not including this alteration will produce an error due to different vector lengths.</p>
<pre class="r"><code>#inspect density of between/within community ties
print(blockmodel(flomarr.stat,comm.spin$membership)$block.model, digits=2)</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4
## Block 1    0.00   0.125   0.250   0.000
## Block 2    0.12   0.333   0.208   0.062
## Block 3    0.25   0.208   0.200   0.083
## Block 4    0.00   0.062   0.083   0.500</code></pre>
<pre class="r"><code>#add community membership as a vertex attribute
flomarr.nodes$comm.spin[which(flomarr.nodes$name%in%V(flomarr.giant)$name)]&lt;-comm.spin$membership
#summarize node statistics by community
nodes.by.gp(flomarr.nodes,&quot;comm.spin&quot;)</code></pre>
<pre><code>##      comm.spin degree   bonpow betweenness close constraint eigen eigen.rc
## [1,]         1    1.5 -9.5e-02         6.5  0.38       0.75 0.095    0.032
## [2,]         2    3.2 -4.3e-01         6.5  0.48       0.52 0.293    0.091
## [3,]         3    3.0 -7.8e-17        14.9  0.51       0.53 0.288    0.082
## [4,]         4    2.2 -1.0e+00        10.6  0.44       0.65 0.174    0.057
## [5,]        NA    0.0  0.0e+00         0.0  0.00       0.00 0.000      NaN
##      eigen.dc comm.fg comm.wt comm.lab comm.edge comm.eigen n
## [1,]    0.063     1.0     4.0      1.0         1        1.0 2
## [2,]    0.202     3.0     3.0      2.0         3        3.0 4
## [3,]    0.207     1.4     2.2      1.4         1        1.6 5
## [4,]    0.117     2.0     1.0      1.5         2        4.0 4
## [5,]      NaN     4.0     5.0      3.0         4        2.0 1</code></pre>
<pre class="r"><code>#plot network with community coloring
plot(comm.spin,flomarr.ig)</code></pre>
<p><img src="NetCommunity_files/figure-html/unnamed-chunk-31-1.png" width="624" /></p>
<p>Compare the various community partitions created so far. Because the original network was not connected and we had to extract a giant component, comparing the partitions using our custom <code>compare.alg</code> function would require additional steps to make the partitions comparable (i.e., have the same number of nodes.) This is not done in this tutorial, but could be done if required.</p>
<pre class="r"><code>#collect modularity scores to compare
mods&lt;-c(mods, eigen=modularity(comm.spin))
mods</code></pre>
<pre><code>## fastgreedy   walktrap      label       edge      eigen      eigen 
##  0.4410431  0.3922902  0.3356009  0.4342404  0.4070295  0.3975000</code></pre>
<pre class="r"><code>#compare community partitions - not connected</code></pre>
<div id="section-exercise-spinglass-community-detection" class="section level3">
<h3>Exercise: Spinglass Community Detection</h3>
<p>Repeat the basic community analysis routine for one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="spinglass" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: spinglass

#Inspect community membership

#inspect density of between/within community ties

#add community membership as a vertex attribute

#summarize node statistics by community

#plot the network with community coloring

#compare modularity scores

#compare community partitions (only if connected)</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="spinglass-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Run clustering algorithm: spinglass
got.spin&lt;-spinglass.community(gotmarr.ig)
#Inspect community membership
igraph::groups(got.spin)
#inspect density of between/within community ties
print(blockmodel(gotmarr.stat,got.spin$membership)$block.model, digits=2)
#add community membership as a vertex attribute
got.nodes$comm.spin&lt;-got.spin$membership
#summarize node statistics by community
nodes.by.gp(gotmarr.nodes,&quot;comm.spin&quot;)
#plot the network with community coloring
plot(got.spin,gotmarr.ig)
#collect modularity scores to compare
mods&lt;-c(mods, spin=modularity(comm.spin))
mods
#compare community partitions
compare.algs(alg.a=c(&quot;got.fg&quot;,&quot;got.wt&quot;, &quot;got.lab&quot;, &quot;got.edge&quot;, &quot;got.eigen&quot;), alg.b=&quot;got.spin&quot;)

#alliances
#extract giant component
alliances.giant&lt;-giant.component(alliances.ig)
alliances.spin&lt;-spinglass.community(alliances.giant)
igraph::groups(alliances.spin)
print(blockmodel(alliances.stat,alliances.spin$membership)$block.model, digits=2)
alliances.nodes$comm.spin[which(alliances.nodes$name%in%V(alliances.giant)$name)]&lt;-alliances.spin$membership
nodes.by.gp(alliances.nodes,&quot;comm.spin&quot;)
plot(alliances.spin,alliances.ig)
mods&lt;-c(mods, spin=modularity(comm.spin))
mods

#airport flights
airports.fl.spin&lt;-spinglass.community(airports.fl.ig)
igraph::groups(airports.fl.spin)
print(blockmodel(airports.fl.stat,airports.fl.spin$membership)$block.model, digits=2)
airports.fl.nodes$comm.spin&lt;-airports.fl.spin$membership
nodes.by.gp(airports.fl.nodes,&quot;comm.spin&quot;)
plot(airports.fl.spin,airports.fl.ig)
mods&lt;-c(mods, spin=modularity(comm.spin))
mods
compare.algs(alg.a=c(&quot;airports.fl.fg&quot;,&quot;airports.fl.wt&quot;, &quot;airports.fl.lab&quot;, &quot;airports.fl.edge&quot;, &quot;airports.fl.eigen&quot;), alg.b=&quot;airports.fl.spin&quot;)

#airport geography
airports.geo.spin&lt;-spinglass.community(airports.geo.ig)
igraph::groups(airports.geo.spin)
print(blockmodel(airports.geo.stat,airports.geo.spin$membership)$block.model, digits=2)
airports.geo.nodes$comm.spin&lt;-airports.geo.spin$membership
nodes.by.gp(airports.geo.nodes,&quot;comm.spin&quot;)
plot(airports.geo.spin,airports.geo.ig)
mods&lt;-c(mods, spin=modularity(comm.spin))
mods
compare.algs(alg.a=c(&quot;airports.geo.fg&quot;,&quot;airports.geo.wt&quot;, &quot;airports.geo.lab&quot;, &quot;airports.geo.edge&quot;, &quot;airports.geo.eigen&quot;), alg.b=&quot;airports.geo.spin&quot;)</code></pre>
</div>

<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(statnet)
library(tidyverse)
load("Week7.rdata")
tutorial_options(exercise.timelimit = 10)
knitr::opts_knit$set(global.par = TRUE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-describe-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-describe-code-editor`)), session)
output$`tutorial-exercise-describe-output` <- renderUI({
  `tutorial-exercise-describe-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-structure-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-structure-code-editor`)), session)
output$`tutorial-exercise-structure-output` <- renderUI({
  `tutorial-exercise-structure-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-nodes-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-nodes-code-editor`)), session)
output$`tutorial-exercise-nodes-output` <- renderUI({
  `tutorial-exercise-nodes-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-cluster-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-cluster-code-editor`)), session)
output$`tutorial-exercise-cluster-output` <- renderUI({
  `tutorial-exercise-cluster-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-density-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-density-code-editor`)), session)
output$`tutorial-exercise-density-output` <- renderUI({
  `tutorial-exercise-density-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-nodeinfo-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-nodeinfo-code-editor`)), session)
output$`tutorial-exercise-nodeinfo-output` <- renderUI({
  `tutorial-exercise-nodeinfo-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-plot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-plot-code-editor`)), session)
output$`tutorial-exercise-plot-output` <- renderUI({
  `tutorial-exercise-plot-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-walktrap-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-walktrap-code-editor`)), session)
output$`tutorial-exercise-walktrap-output` <- renderUI({
  `tutorial-exercise-walktrap-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-compare-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-compare-code-editor`)), session)
output$`tutorial-exercise-compare-output` <- renderUI({
  `tutorial-exercise-compare-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-labprop-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-labprop-code-editor`)), session)
output$`tutorial-exercise-labprop-output` <- renderUI({
  `tutorial-exercise-labprop-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-between-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-between-code-editor`)), session)
output$`tutorial-exercise-between-output` <- renderUI({
  `tutorial-exercise-between-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-eigen-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-eigen-code-editor`)), session)
output$`tutorial-exercise-eigen-output` <- renderUI({
  `tutorial-exercise-eigen-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-spinglass-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-spinglass-code-editor`)), session)
output$`tutorial-exercise-spinglass-output` <- renderUI({
  `tutorial-exercise-spinglass-result`()
})
</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery-1.11.3"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap-3.3.5"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery-1.11.3"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.0.13"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/fontawesome-all.min.js","js/fa-v4-shims.min.js"]},{"type":"character","attributes":{},"value":["css/fa-svg-with-js.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["4.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["localforage"]},{"type":"character","attributes":{},"value":["1.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/localforage"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["localforage.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]}]}]}
</script>
<!--/html_preserve-->
</div>
</div>

</div> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h2 class="title toc-ignore" style="display:none;">Week 7 Syntax Notebook</h2>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</div> <!-- bandContent page -->
</div> <!-- pageContent band -->




<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>

</html>
