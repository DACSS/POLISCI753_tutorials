<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />

<title>Week 6 Syntax Notebook</title>


<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>



<div class="pageContent band">
<div class="bandContent page">

<div class="topics">

<div id="section-introduction" class="section level2">
<h2><strong>Introduction</strong></h2>
<p>This tutorial will demonstrate use of the R commands used in each step of the process to identify network role equivalence introduced in Week 6’s Lecture:</p>
<ul>
<li>Cluster data based on distance matrix</li>
<li>Partition network into positions using clustering results</li>
<li>Blockmodel Positions</li>
<li>Plot Positions</li>
</ul>
<p>We will also introduce available options for choosing a distance matrix, clustering based on distance, and choosing partition cutpoints. * Distance matrices for weighted and unweighted networks * Clustering using structural equivalence, concor, regular equivalence, and criteron-basedgeneralized blockmodeling * Choosing partition cutpoints</p>
<p>We will be using several datasets for this exercise: <code>gotmarr</code> (Game of Thrones marriages), <code>monks</code>; sampson’s monks (which are also available as liking networks at three different timeponts using data(samplk)), <code>flomarr</code>: padgett florentine families, and <code>gotpart</code> (Game of Thrones partners, including marriages and affairs).</p>
<ul>
<li><em>gotmarr.ig</em> - Game of Thrones marriages and engagements igraph network object</li>
<li><p><em>gotmarr.stat</em> - Game of Thrones marriages and engagements statnet network object</p></li>
<li><em>gotpart.ig</em> - Game of Thrones marriages and affairs igraph network object</li>
<li><p><em>gotpart.stat</em> - Game of Thrones marriages and affairs statnet network object</p></li>
<li><em>flomarr.ig</em> - Floretine Families igraph network object</li>
<li><p><em>flomarr.stat</em> - Floretine Families statnet network object</p></li>
<li><em>monks.ig</em> - Game of Thrones marriages igraph network object</li>
<li><p><em>monks.stat</em> - Sampson’s monks statnet network object</p></li>
</ul>
<p>We will also be creating structural equivalence models for each of these datasets. Replace the word dataset with the name of the dataset. We will learn more about these later in the tutorial:</p>
<ul>
<li><em>dataset.se</em> - default</li>
<li><em>dataset.avg.se</em> - cluster method = average</li>
<li><em>dataset.sing.se</em> - cluster method = single</li>
<li><em>dataset.wrd.se</em> - cluster method = ward.D</li>
</ul>
</div>
<div id="section-basic-network-description" class="section level2">
<h2><strong>Basic Network Description</strong></h2>
<div id="section-inspect-basic-network-descriptors" class="section level3">
<h3>1. Inspect basic <strong>network descriptors</strong></h3>
<p>Inspect the network attributes of the <code>flomarr</code>, <code>gotmarr</code> and <code>gotpart</code> and <code>monks</code> networks. For this exercise, refer to Week 1 tutorial. This will help you get familiar with the dataset you are using.</p>
<p>Find network size, type (un/directed, un/weighted, bipartite) and available attributes of vertices and edges</p>
<div class="tutorial-exercise" data-label="describe" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Find network size and type</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="describe-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Find network size and type</code></pre>
</div>
</div>
<div id="section-inspect-the-network-structure" class="section level3">
<h3>2. Inspect the Network Structure</h3>
<p>Inspect the <strong>dyads, triads, and component structure</strong> of the <code>flomarr</code>, <code>gotmarr</code> and <code>gotpart</code> and <code>monks</code> networks (refer to tutorial 2). Pay attention to whether network is connected, as it affects the otions you use for closeness centrality.</p>
<div class="tutorial-exercise" data-label="structure" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Dyad census, triad census, number and size of components, isolates</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="structure-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Dyad census, triad census, number and size of components, isolates</code></pre>
</div>
</div>
<div id="section-create-a-network.nodes-dataframe" class="section level3">
<h3>3. Create a <em>network</em>.nodes dataframe</h3>
<p>Create a dataframe of standard, applicable node-level measures (from weeks 3-5.) Note that the routine below requires two custom functions to be used for the calculation of derived and reflected centrality. These functions can be included in network analysis files, or turned into a library and loaded like a standard R library.</p>
<pre class="r"><code>get.eigen&lt;-function(net, attr=NULL){
    #set attr=&quot;weight&quot; if weighted network
    eigen&lt;-evcent(net)
    mat&lt;-as.matrix.network(net, attr=attr)
    diag(mat)&lt;-0
    mat2&lt;-mat%*%mat
    rc&lt;-diag(mat2)/rowSums(mat2)
    dc&lt;-1-rc
    data.frame(name=net%v%&quot;vertex.names&quot;,
        eigen=eigen,
        eigen.rc=eigen*rc,
        eigen.dc=eigen*dc)
}
get.brokerage&lt;-function(net, attr=&quot;attr&quot;){
  temp&lt;-data.frame(brokerage(net, cl = net%v%&quot;attr&quot;)$z.nli)
  temp$name=net%v%&quot;vertex.names&quot;
  mutate(temp, broker.tot = temp$t,
         broker.coord = temp$w_I,
         broker.itin = temp$w_O,
         broker.rep = temp$b_IO,
         broker.gate = temp$b_OI,
         broker.lia = temp$b_O)
}</code></pre>
<p>With those two functions defined, lets condense the three previous weeks exercises calculating varius measures of centrality into a standard routine, with abbreviated notes on when to use each measure.</p>
<pre class="r"><code>#create dataframe with names
#add degree if undirected
#add degree.wt if weighted (and makes sense)
#else add indegree and outdegree if directed
#add sna::bompow for non-singular, unweighted matrix
#else add igraph::power_centrality()
#add betweenness, set gmode for undirected
#add closeness, set gmode for undirected and cmode if not connected
#add constraint (igraph)
flomarr.nodes&lt;-data.frame(name=flomarr.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(flomarr.stat,gmode=&quot;graph&quot;),
#       degree.wt=strength(network.ig),
        bonpow=bonpow(flomarr.stat),
        betweenness=betweenness(flomarr.stat, gmode=&quot;graph&quot;),
        close=sna::closeness(flomarr.stat, gmode=&quot;graph&quot;),
        constraint=constraint(flomarr.ig))

#add eigenvector centrality using custom function
flomarr.nodes&lt;-full_join(flomarr.nodes,get.eigen(flomarr.stat), by=&quot;name&quot;)

#add brokerage using custom func. if vertex attribute and directed
#doesn&#39;t work for this dataset
#network.nodes&lt;-full_join(network.nodes,get.brokerage(network.stat, &quot;attr&quot;), by=&quot;name&quot;)</code></pre>
</div>
<div id="section-exercise-node-measures-dataframe" class="section level3">
<h3>Exercise: Node Measures dataframe</h3>
<p>Now, calculate the same node measures dataframe from one of the other datasets provided this week.</p>
<div class="tutorial-exercise" data-label="nodes" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#create dataframe with names
#add degree if undirected
#add degree.wt if weighted (and makes sense)
#else add indegree and outdegree if directed
#add sna::bompow for non-singular, unweighted matrix
#else add igraph::power_centrality()
#add betweenness, set gmode for undirected
#add closeness, set gmode for undirected and cmode if not connected
#add constraint (igraph)

#add eigenvector centrality using custom function

#add brokerage using custom func. if vertex attribute + directed</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="nodes-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#create dataframe with names
#add degree if undirected
#add degree.wt if weighted (and makes sense)
#else add indegree and outdegree if directed
#add sna::bompow for non-singular, unweighted matrix
#else add igraph::power_centrality()
#add betweenness, set gmode for undirected
#add closeness, set gmode for undirected and cmode if not connected
#add constraint (igraph)
gotmarr.nodes&lt;-data.frame(name=gotmarr.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(gotmarr.stat,gmode=&quot;graph&quot;),
        degree.wt=strength(gotmarr.ig),
        bonpow=bonpow(gotmarr.stat),
        betweenness=betweenness(gotmarr.stat, gmode=&quot;graph&quot;),
        close=sna::closeness(gotmarr.stat, gmode=&quot;graph&quot;),
        constraint=constraint(gotmarr.ig))

#add eigenvector centrality using custom function
gotmarr.nodes&lt;-full_join(gotmarr.nodes,get.eigen(gotmarr.stat, &quot;weight&quot;), by=&quot;name&quot;)

#add brokerage using custom func. if vertex attribute + directed
gotmarr.nodes&lt;-full_join(gotmarr.nodes,get.brokerage(gotmarr.stat, &quot;attr&quot;), by=&quot;name&quot;)


head(gotmarr.nodes) #to see your dataframe</code></pre>
</div>
</div>
</div>
<div id="section-calculate-structural-equivalence" class="section level2">
<h2><strong>Calculate Structural Equivalence</strong></h2>
<p>In calculating structural equivalence, we are interested in identifying nodes that have the same pattern of ties with the same neighbors. The statnet function <code>equiv.clust()</code> compresses the first two steps of role detection–creating a distance (similarity) matrix and then clustering the nodes on the basis of that matrix–into a single function. The distance matrix is calculated based on the option <code>method=</code> and can be set to different distance functions such as hamming, correlation, hamming, or gamma when using structural equivalence <code>equiv.fun=&quot;sedist&quot;</code> as the basis for clustering.</p>
<pre class="r"><code>#calculate equivalence from specified distance marix
flomarr.se&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;sedist&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)</code></pre>
<p>While this creates the element in your environment, R won’t print any results from it. The next step of the tutorial evaluates this element.</p>
<div id="section-exercise-calculate-se-clusters" class="section level3">
<h3>Exercise: Calculate SE Clusters</h3>
<p>Now, create a structural equivalence cluster using one of the other datasets this week: Sampson’s monks, GoT marriages, and/or GoT engagements. Note that although all three of these networks are valued and have a <em>weight</em> edge attribute, the statnet <code>sedist()</code> function used by <code>equiv.clust()</code> ignores the edge values. Later in this tutorial, an alternative approach to calculating sedist that can incorporate edge values is introduced.</p>
<div class="tutorial-exercise" data-label="sedist" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#calculate equivalence from specified distance marix</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="sedist-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#calculate equivalence from specified distance marix

#got marriages:
flomarr.se&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;sedist&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)

#got partners
gotmarr.se&lt;-equiv.clust(gotmarr.stat, equiv.fun=&quot;sedist&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)

#monks
monks.se&lt;-equiv.clust(monks.stat, equiv.fun=&quot;sedist&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-dendrogram-of-se-clusters" class="section level2">
<h2><strong><em>Dendrogram of SE Clusters</em></strong></h2>
<p>The <code>equiv.clust()</code> command returns an object with several components that will likely be familiar to those of you familiar with hierarchical clustering in general. Lets take a look at the components of the object returned by <code>equiv.clust()</code>.</p>
<pre class="r"><code>#summary of object produced by sedist()
summary(flomarr.se)</code></pre>
<pre><code>##                Length Class  Mode     
## cluster         7     hclust list     
## metric          1     -none- character
## equiv.fun       1     -none- character
## cluster.method  1     -none- character
## glabels        16     -none- character
## plabels        16     -none- character</code></pre>
<p>As you can see, the <em>cluster</em> component is of class <em>hclust</em>. This means that we can plot it in a tree or dendrogram form just like traditional hierarchical clustering output.</p>
<pre class="r"><code>#plot equivalence clustering
plot(flomarr.se)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-6-1.png" width="624" /></p>
<p>For those not familiar with hierarchical clustering, this is a tree that shows how closely related the nodes are to each other. The <em>height</em> dimension on the y-axis indicates how different the nodes are from each other, with higher numbers indicating a greater degree of difference. The node indices are the numbers appearing on the x-axis. The difference between two nodes is indicated by a link at the specified height. So nodes 11 and 15 are closely related to each other (at a height of around 2), and there is only a small difference between nodes these nodes and nodes 4 and 5. Node 9 is clearly different compared to the other nodes.</p>
<p>If we would like to see the names of the nodes in the dendrogram, we can access vertex names in the clustering object component <em>glabels</em>. The vertex names are automatically reordered correctly.</p>
<pre class="r"><code>#plot equivalence clustering
plot(flomarr.se,labels=flomarr.se$glabels)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-7-1.png" width="624" /></p>
<p><code>equiv.clust()</code> has a default cluster method setting. See help for <code>hclust()</code> for additional options. You may want to experiment with using different methods for the option <code>equiv.clust(..., cluster.method=&quot;&quot;)</code>, replacing the default <code>cluster.method=&quot;complete&quot;</code> with an alternative such as <em>single, average</em>, or <em>ward.D</em>. How does changing the clustering method change which nodes are closest to each other? For the Florentine Marriages dataset, here are the dedrograms for the alternative settings:</p>
<pre class="r"><code>#with average cluster.method
flomarr.avg.se&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;sedist&quot;, cluster.method=&quot;average&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)

#plot:
plot(flomarr.avg.se,labels=flomarr.se$glabels)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-8-1.png" width="624" /></p>
<p>And single:</p>
<pre class="r"><code>#with single cluster.method
flomarr.sing.se&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;sedist&quot;, cluster.method=&quot;single&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)

#plot:
plot(flomarr.sing.se,labels=flomarr.se$glabels)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-9-1.png" width="624" /></p>
<p>And ward.D:</p>
<pre class="r"><code>#with ward.D cluster.method
flomarr.wrd.se&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;sedist&quot;, cluster.method=&quot;ward.D&quot;, method=&quot;hamming&quot;,mode=&quot;graph&quot;)

#plot:
plot(flomarr.wrd.se,labels=flomarr.se$glabels)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-10-1.png" width="624" /></p>
<p>What do you notice about the differences? How does the clustering method change how the data is disaplayed?</p>
<div id="section-exercise-dendrogram" class="section level3">
<h3>Exercise: Dendrogram</h3>
<p>Now, inspect the clusters using one of the other datasets this week: Sampson’s monks, GoT marriages, and/or GoT engagements. You may want to experiment with using different methods for the option <code>equiv.clust(..., cluster.method=&quot;&quot;)</code>, replacing the default <code>cluster.method=&quot;complete&quot;</code> with an alternative such as <em>single, average</em>, or <em>ward.D</em>. For this tutorial, we’ve included the .se elements for each dataset with the clustering methods: <code>dataset.avg.se</code>, <code>dataset.sing.se</code>, <code>dataset.wrd.se</code> and, of course, the default <code>dataset.se</code>. Simply replace the name with the dataset you want to explore.</p>
<p>How does changing the clustering method change which nodes are closest to each other?</p>
<div class="tutorial-exercise" data-label="plotequiv" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#plot equivalence clustering</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="plotequiv-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#plot equivalence clustering.
#For whichever you choose, compare to the avg sing and wrd cluster methods. To do this, change the data element in the plot() command.

#got marriages
summary(gotmarr.se)
plot(gotmarr.se,labels=gotmarr.se$glabels)


#got partners
summary(gotpart.se)
plot(gotpart.se,labels=gotpart.se$glabels)

#monks
summary(monks.se)
plot(monks.se,labels=monks.se$glabels)</code></pre>
</div>
</div>
</div>
<div id="section-partition-a-matrix-using-clustering" class="section level2">
<h2><strong>Partition a Matrix Using Clustering</strong></h2>
<p>Looking at the dendrogram, it is clear that the number of partitions (or roles) will depend on the height at which the dendrogram is cut. For example, we could set the height at 15 and the result would be two clusters.</p>
<pre class="r"><code>#plot equivalence clustering
plot(flomarr.se,labels=flomarr.se$glabels)
#partition the clusters
rect.hclust(flomarr.se$cluster,h=15)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-11-1.png" width="624" /></p>
<p>Alternatively, we could set the height at 10, and identify 4 distinct clusters or roles.</p>
<pre class="r"><code>#plot equivalence clustering
plot(flomarr.se,labels=flomarr.se$glabels)
#partition the clusters
rect.hclust(flomarr.se$cluster,h=10)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-12-1.png" width="624" /></p>
<p>In practice, there are different approaches to identifying the best cutpoint to use as the basis for partitioning, and we explore those in more detail below. For now, we will use the two cutpoints here and visually inspect the resulting partitions.</p>
<div id="section-exercise-partitioning-clusters" class="section level3">
<h3>Exercise: Partitioning Clusters</h3>
<p>Now, partition the clusters you have created in the earlier Dendrogram exercise using one of the other datasets this week: <code>monks</code>, <code>gotmarr</code>, and/or <code>gotpart</code>. As in the previous exercise, you can either use the default structural equivalence cluster created for each dataset, or experiment with creating your own equivalence clusters using different clustering methods such as <em>simple</em>, <em>Ward.D</em> or <em>average</em>.</p>
<div class="tutorial-exercise" data-label="partition" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="6">
<pre class="text"><code>#plot equivalence clustering using default or a different clustering method

#partition the clusters</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="partition-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#plot equivalence clustering using default or a different clustering method
#got marriages
plot(gotmarr.se,labels=gotmarr.se$glabels)
#partition the clusters
#gotmarriages
rect.hclust(gotmarr.se$cluster,h=10)

#got partners
plot(gotpart.se,labels=gotpart.se$glabels)
rect.hclust(gotpart.se$cluster,h=10)

#monks
plot(monks.se,labels=monks.se$glabels)
rect.hclust(monks.se$cluster,h=10)</code></pre>
</div>
</div>
</div>
<div id="section-blockmodel-partitions" class="section level2">
<h2><strong>Blockmodel Partitions</strong></h2>
<p>One easy way to inspect the goodness of fit of the partitions that result from the clustering steps above is to use blockmodeling. This is because the goal of structural equivalence clustering is to create a grid of 0 blocks (where there are no relationships) and 1 blocks (with all possible relationships.) In practice, we usually don’t find perfect 0 and 1 blocks, but we can look at block density and also the visual blockmodel plot to get a sense of how well the partitioning worked. Note that plotting the underlying network as a blockmodel works best with smaller networks, and can become difficult to understand with larger networks.</p>
<p>To implement a blockmodel in statnet, we must specify the original network, the equivalence clustering object to use, and the number of partitions. The option <code>k=</code> in the <code>blockmodel</code> command indicates how many partitions to use in creating the blockmodel. Alternatively, the option <code>h=</code> indicates the height at which to cut the dendrogram.</p>
<pre class="r"><code>#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=2)
#print blockmodel object
blk_mod</code></pre>
<pre><code>## 
## Network Blockmodel:
## 
## Block membership:
## 
##   Acciaiuoli      Albizzi    Barbadori     Bischeri   Castellani 
##            1            1            1            1            1 
##       Ginori     Guadagni Lamberteschi       Medici        Pazzi 
##            1            1            1            2            1 
##      Peruzzi        Pucci      Ridolfi     Salviati      Strozzi 
##            1            1            1            1            1 
##   Tornabuoni 
##            1 
## 
## Reduced form blockmodel:
## 
##   Acciaiuoli Albizzi Barbadori Bischeri Castellani Ginori Guadagni Lamberteschi Medici Pazzi Peruzzi Pucci Ridolfi Salviati Strozzi Tornabuoni 
##           Block 1 Block 2
## Block 1 0.1333333     0.4
## Block 2 0.4000000     NaN</code></pre>
<pre class="r"><code>#plot blockmodel partitions
plot(blk_mod)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-14-1.png" width="100%" /></p>
<p>Note that while it is possible to use the simple <code>plot()</code> command to plot the resulting blockmodel object, there are some issues with the plot: the title is strange, and the node labels are difficult to read. Therefore, we are going to create a new function, plot.block(), that is a little more flexible in terms of setting the title and label size for blockmodel plots.</p>
<pre class="r"><code>plot.block&lt;-function(x=blk_mod, main=NULL, cex.lab=1){
  plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),
                   main=main, drawlines = FALSE, cex.lab=cex.lab)
  for (j in 2:length(x$plabels)) if (x$block.membership[j] !=
                                     x$block.membership[j-1]) 
    abline(v = j - 0.5, h = j - 0.5, lty = 3, xpd=FALSE)
}</code></pre>
<pre class="r"><code>#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=2)
#plot partitions
plot.block(blk_mod,main=&quot;Florentine Marriages: 2 Partitions&quot;, cex.lab=.5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-16-1.png" width="100%" /></p>
<p>Now see what happens when we plot the 5 partitions isolated in the earlier exercise.</p>
<pre class="r"><code>#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=5)
#print blockmodel object
blk_mod$block.model</code></pre>
<pre><code>##            Block 1    Block 2   Block 3   Block 4   Block 5
## Block 1 0.05555556 0.02777778 0.3333333 0.5555556 0.1111111
## Block 2 0.02777778 0.83333333 0.2500000 0.0000000 0.2500000
## Block 3 0.33333333 0.25000000       NaN 0.0000000 0.0000000
## Block 4 0.55555556 0.00000000 0.0000000       NaN 1.0000000
## Block 5 0.11111111 0.25000000 0.0000000 1.0000000       NaN</code></pre>
<pre class="r"><code>#plot blockmodel partitions
plot.block(blk_mod,main=&quot;Florentine Marriages, 5 Partitions&quot;, cex.lab=.5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-17-1.png" width="100%" /></p>
<div id="section-exercise-blockmodel-partitions" class="section level3">
<h3>Exercise: Blockmodel Partitions</h3>
<p>Now, plot the partitions that you created in the previous exercises using one of the other datasets this week: <code>monks</code>, <code>gotmarr</code>, and/or <code>gotpart</code>. You may want to plot several of them to compare. Did the partitions that made sense when plotted as a dendrogram also make sense when you plot the blockmodel? Are you approaching 0 and 1 blocks in your partitions? Do any of the nodes that don’t quite fit exhibit distinctive behaviors?</p>
<div class="tutorial-exercise" data-label="block" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="8">
<pre class="text"><code>#blockmodel and select partitions for one of the other datasets

#print blockmodel object

#plot blockmodel partitions</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="block-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#blockmodel and select partitions for one of the other datasets

#print blockmodel object

#plot blockmodel partitions</code></pre>
</div>
</div>
</div>
<div id="section-plot-network-roles" class="section level2">
<h2><strong>Plot Network Roles</strong></h2>
<p>When we create a blockmodel object, the component <em>block.membership</em> is used to tell us which role (or block) each node has been assigned. It can be useful to take this information and superimpose it on a traditional network plot. To do this, we will first assign <code>blk_mod$block.membership</code> as a vertex attribute.</p>
<pre class="r"><code>#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=5)
#assign block membership to vertex attribute
V(flomarr.ig)$role&lt;-blk_mod$block.membership[match(V(flomarr.ig)$name,blk_mod$plabels)]</code></pre>
<p>Now, we can use the <em>role</em> attribute to change the color of plotted nodes in a network plot. Statnet plots aren’t that attractive without using ggnet2, which is what we use here. Alternatively, igraph also produces nice looking network plots by default. For more on producing new network plots in R, see the suggested online tutorials linked on Google classroom.</p>
<pre class="r"><code>#plot network using &quot;role&quot; to color nodes: statnet
GGally::ggnet2(flomarr.stat,
               node.color=&quot;role&quot;, 
               node.size=degree(flomarr.stat, gmode=&quot;graph&quot;),
               node.label = &quot;vertex.names&quot;,
               node.alpha = .5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-19-1.png" width="624" /></p>
<pre class="r"><code>#plot network using &quot;role&quot; to color nodes: igraph
plot.igraph(flomarr.ig, 
            vertex.color=V(flomarr.ig)$role,
            vertex.size=8+(igraph::degree(flomarr.ig)*4))</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-19-2.png" width="624" /></p>
<p>Additional options can be used to finetune graphics, such as changing the color, making the nodes larger, smaller or more transparent, removing the circles at the nodes and coloring the node labels instead, etc. For directed networks, additional options that might be useful include <code>arrow.size</code> and <code>arrow.gap</code> in ggnet2. When using <code>igraph.plot()</code>, it is helpful to set all margins of the figure to 0 using <code>par(mar=c(0,0,0,0))</code> but this isn’t necessary using ggnet2.</p>
<div id="section-exercise-plot-network-role" class="section level3">
<h3>Exercise: Plot Network Role</h3>
<div class="tutorial-exercise" data-label="roleplot" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="8">
<pre class="text"><code>#calculate equivalence from specified distance marix

#blockmodel and select partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="roleplot-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>## replace the flomarr element with the dataset of your choice:

#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=5)
#assign block membership to vertex attribute
V(flomarr.ig)$role&lt;-blk_mod$block.membership[match(V(flomarr.ig)$name,blk_mod$plabels)]

#plot network using &quot;role&quot; to color nodes: statnet
GGally::ggnet2(flomarr.stat,
               node.color=&quot;role&quot;, 
               node.size=degree(flomarr.stat, gmode=&quot;graph&quot;),
               node.label = &quot;vertex.names&quot;,
               node.alpha = .5)
#plot network using &quot;role&quot; to color nodes: igraph
plot.igraph(flomarr.ig, 
            vertex.color=V(flomarr.ig)$role,
            vertex.size=8+(igraph::degree(flomarr.ig)*4))</code></pre>
</div>
</div>
</div>
<div id="section-compare-network-role-and-centrality" class="section level2">
<h2><strong>Compare Network Role and Centrality</strong></h2>
<p>Let’s compare network roles to our centrality values we explored in tutorials 3 and 4. Using the <em>.nodes</em> dataframe that you created in the earlier part of this tutorial, add the network role value. Then, let’s plot the correlations so we can easily compare this value to our centrality values.</p>
<p>Using the <code>flomarr</code> example earlier, let’s repeat the steps and add our <code>blockmod</code> calculations.</p>
<pre class="r"><code>###Repeat the blockmodeling and creating the vertex attribute to be able to attach to the .nodes element.
#blockmodel and select partitions
blk_mod&lt;-blockmodel(flomarr.stat,flomarr.se,k=5)
#assign block membership to vertex attribute
V(flomarr.ig)$role&lt;-blk_mod$block.membership[match(V(flomarr.ig)$name,blk_mod$plabels)]


flomarr.nodes&lt;-data.frame(name=flomarr.stat%v%&quot;vertex.names&quot;,
                          degree=sna::degree(flomarr.stat,gmode=&quot;graph&quot;),
                  #       degree.wt=strength(network.ig),
                          bonpow=bonpow(flomarr.stat),
                          betweenness=betweenness(flomarr.stat, gmode=&quot;graph&quot;),
                          close=sna::closeness(flomarr.stat, gmode=&quot;graph&quot;),
                          constraint=constraint(flomarr.ig), 
                          role=V(flomarr.ig)$role)</code></pre>
<div id="section-exercise-roles-centrality" class="section level3">
<h3>Exercise: Roles &amp; Centrality</h3>
<div class="tutorial-exercise" data-label="roles and cent" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Repeat the block modeling exercise for a dataset of your choice

#repeat part 3 of basic network structure to create a .nodes dataframe, attaching the role

#add eigenvector centrality using custom function

#add brokerage using custom func. if vertex attribute + directed</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="roles and cent-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#Repeat the block modeling exercise for a dataset of your choice
blk_mod&lt;-blockmodel(gotmarr.stat,gotmarr.se,k=5)
V(gotmarr.ig)$role&lt;-blk_mod$block.membership[match(V(gotmarr.ig)$name,blk_mod$plabels)]

#repeat part 3 of basic network structure to create a .nodes dataframe, attaching the role
gotmarr.nodes&lt;-data.frame(name=gotmarr.stat%v%&quot;vertex.names&quot;,
        degree=sna::degree(gotmarr.stat,gmode=&quot;graph&quot;),
        degree.wt=strength(gotmarr.ig),
        bonpow=bonpow(gotmarr.stat),
        betweenness=betweenness(gotmarr.stat, gmode=&quot;graph&quot;),
        close=sna::closeness(gotmarr.stat, gmode=&quot;graph&quot;),
        constraint=constraint(gotmarr.ig),
        role=V(gotmarr.ig)$role) #final addition of role

#add eigenvector centrality using custom function
gotmarr.nodes&lt;-full_join(gotmarr.nodes,get.eigen(gotmarr.stat, &quot;weight&quot;), by=&quot;name&quot;)

#add brokerage using custom func. if vertex attribute + directed
gotmarr.nodes&lt;-full_join(gotmarr.nodes,get.brokerage(gotmarr.stat, &quot;attr&quot;), by=&quot;name&quot;)</code></pre>
</div>
</div>
</div>
<div id="section-structural-equivalence-weighted" class="section level2">
<h2><strong>Structural Equivalence: Weighted</strong></h2>
<p>The statnet package version of the command <code>sedist()</code> currently ignores any edge values or weights. Therefore, we will be using the <code>sedist()</code> function available in a different r library called <code>blockmodeling</code> to create equivalence cluster objects for weighted networks. This is a little tricky to implment in your own version of R, as you will need to install the library <em>blockmodeling</em>, and you will also need to transform an igraph <code>graph</code> object into a valued adjency matrix that is a <code>matrix</code> object. The commands you will need to install the package are provided but are not evaluated here as the package is already installed. This demonstration uses Sampson’s monks dataset, where weights are stored as the <em>nominations</em> edge attribute.</p>
<pre class="r"><code>#install library
install(&quot;blockmodeling&quot;)</code></pre>
<p>We also need to create a weighted adjacency matrix from an existing network, as the new <code>sedist()</code> function requires a matrix object.</p>
<pre class="r"><code>#transform .ig into .mat object
monks.mat&lt;-as.matrix(as_adj(monks.ig,attr = &quot;nominations&quot;))
#inspect for accuracy
monks.mat[1:5,1:5]</code></pre>
<pre><code>##             John Bosco Gregory Basil Peter Bonaventure
## John Bosco           0       1     2     0           2
## Gregory              3       0     0     0           0
## Basil                3       1     0     0           0
## Peter                0       0     0     0           3
## Bonaventure          1       0     0     3           0</code></pre>
<p>In the earlier steps, we established a standard routine for creating a distance matrix, finding an equivalence cluster, partitioning the cluster, and inspecting it visually. There is only one significant change needed for weighted networks: the use of a distance matrix suitable for valued networks, such as euclidean distance or correlation in the initial step. Euclidean distance is traditional, and is the default option.</p>
<pre class="r"><code>#calculate equivalence from specified distance marix
monks.sedist&lt;-blockmodeling::sedist(monks.mat)
monks.se&lt;-equiv.clust(monks.stat,
                equiv.dist=monks.sedist)</code></pre>
<p>It can be useful to combine these two steps also, like this.</p>
<pre class="r"><code>#calculate equivalence from specified distance marix
monks.se&lt;-equiv.clust(monks.stat,
                equiv.dist=blockmodeling::sedist(monks.mat))</code></pre>
<p>Once you have the new equivalence clusters, other steps can be completed as above.</p>
<div id="section-exercise-weighted-se-clusters" class="section level3">
<h3>Exercise: Weighted SE Clusters</h3>
<p>The GoT marriages and partners networks also have an edge value attribute, “weight”. Using one of these networks or Sampson’s monks, go through the whole role/position extraction routine as developed above. How do the resulting network partitions compare to the ones identified using the unweighted network? Can you interpret any differences you find in the position of specific nodes?</p>
<div class="tutorial-exercise" data-label="weighted" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="12">
<pre class="text"><code>#calculate equivalence from specified distance marix

#blockmodel and select partitions

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="weighted-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#calculate equivalence from specified distance marix

#blockmodel and select partitions

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
</div>
</div>
</div>
<div id="section-concor-based-partitions" class="section level2">
<h2>CONCOR-based Partitions</h2>
<p>CONCOR is an algorithm developed expressly for blockmodeling. CONCOR partitions the network matrix directly using a CONvergence of iterated CORrelations. The algorithm converges to the 0 and 1 blocks that are desirable in structural equivalence relations.</p>
<p>The CONCOR algorithm is currently only available for R in the concoR package, which is only available on GitHub. To install it on your own computer, use the following steps.</p>
<pre class="r"><code>#install devtools if needed
if(&quot;devtools&quot;   %in% rownames(installed.packages()) == FALSE) {install.packages(&quot;devtools&quot;)}
#install concoR library
devtools::install_github(&quot;aslez/concoR&quot;)
#load concoR library
library(concoR)</code></pre>
<p>The function <code>concor_hca()</code> starts with an adjacency matrix, just like the blockmodeling package, and returns a block membership list, similar to the one returned by <code>blockmodel()</code>. Just as with the <code>blockmodel</code> command, we must indicate the number of desired partitions for CONCOR to return using the parameter <code>p=...</code>.</p>
<pre class="r"><code>#select partitions with concor
concoR::concor_hca(list(flomarr.mat), p=2)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["block"],"name":[1],"type":["int"],"align":["right"]},{"label":["vertex"],"name":[2],"type":["chr"],"align":["left"]}],"data":[{"1":"1","2":"Acciaiuoli","_rn_":"1"},{"1":"2","2":"Albizzi","_rn_":"5"},{"1":"1","2":"Barbadori","_rn_":"2"},{"1":"2","2":"Bischeri","_rn_":"6"},{"1":"3","2":"Castellani","_rn_":"9"},{"1":"4","2":"Ginori","_rn_":"13"},{"1":"4","2":"Guadagni","_rn_":"14"},{"1":"2","2":"Lamberteschi","_rn_":"7"},{"1":"4","2":"Medici","_rn_":"15"},{"1":"4","2":"Pazzi","_rn_":"16"},{"1":"3","2":"Peruzzi","_rn_":"10"},{"1":"3","2":"Pucci","_rn_":"11"},{"1":"1","2":"Ridolfi","_rn_":"3"},{"1":"1","2":"Salviati","_rn_":"4"},{"1":"3","2":"Strozzi","_rn_":"12"},{"1":"2","2":"Tornabuoni","_rn_":"8"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Now, lets take the output from concor and use it to replace the first two steps in our earlier routine as follows.</p>
<pre class="r"><code>#select partitions with concor
blks&lt;-concoR::concor_hca(list(flomarr.mat), p=2)
#blockmodel with concor
blk_mod &lt;- blockmodel(flomarr.stat, blks$block, plabels=blks$vertex) 
#print blockmodel object
blk_mod$block.model</code></pre>
<pre><code>##         Block 1 Block 2 Block 3 Block 4
## Block 1  0.0000  0.0625   0.125  0.3125
## Block 2  0.0625  0.0000   0.125  0.4375
## Block 3  0.1250  0.1250   0.500  0.0000
## Block 4  0.3125  0.4375   0.000  0.0000</code></pre>
<pre class="r"><code>#plot blockmodel partitions
plot.block(blk_mod,main=&quot;Florentine Marriages, Concor 4 Partitions&quot;, cex.lab=.5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-27-1.png" width="100%" /></p>
<pre class="r"><code>#assign block membership to vertex attribute
flomarr.stat%v%&quot;role&quot;&lt;-blks$block[match(flomarr.stat%v%&quot;vertex.names&quot;,blks$vertex)]
#plot network using &quot;role&quot; to color nodes
GGally::ggnet2(flomarr.stat,
               node.color=&quot;role&quot;, 
               node.size=degree(flomarr.stat, gmode=&quot;graph&quot;),
               node.label = &quot;vertex.names&quot;,
               node.alpha = .5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-27-2.png" width="100%" /></p>
<div id="section-exercise-concor" class="section level3">
<h3>Exercise: CONCOR</h3>
<p>Using one of the alternative networks for the week, go through the position extraction routine as developed above. How do the resulting network partitions compare to the ones identified using the hamming distance matrix and hierarchical clustering? Can you interpret any differences you find in the position of specific nodes? Do you think that CONCOR might work better on a different type of network? You may want to repeat this procedure with a different network and see if you are right.</p>
<div class="tutorial-exercise" data-label="concor" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="12">
<pre class="text"><code>#select partitions with concor

#blockmodel with concor

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="concor-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#select partitions with concor

#blockmodel with concor

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
</div>
</div>
</div>
<div id="section-optimization-based-partitions" class="section level2">
<h2><strong>Optimization-based Partitions</strong></h2>
<p>Much like CONCOR, criteron-based optimization can be used to directly partition a network into structurally equivalent positions. The different blockmodel ideals involving 0 and 1 blocks can be used to set a criteron function for optimization of a blockmodel of a particular network. Unfortunately, it is computationally impossible to directly optimize network partitions relative to a critereon. Instead, different algorithms, such as a tabu search or a nearest neighbor search, can be used and compared to the optimizaton critereon to select the best network partition.</p>
<p>The package <em>blockmodeling</em> includes a function for optimization-based partitioning of a network, <code>optRandomParC()</code>. This function generates multiple initial starting partitions randomly, with the number of starting partitions set by the parameter <code>rep=...</code>. As in other clustering functions, the number of desired partitions must be set using the parameter <code>k=...</code>.</p>
<p>At least two additional parameter options are required to specify the criteron to be optimized. The <code>approaches=...</code> option specifies which of several approaches to use, such as “hom” or homogeneity blockmodeling, “bin” or binary blockmodeling, “ss” for sum of squares homogeneity blockmodeling, etc. The <code>blocks=...</code> option is a list of the desired block types, such as “com” for complete, “nul” for the empty block, etc. For more details, see <a href="https://doi-org.silk.library.umass.edu/10.1016/j.socnet.2006.04.002">Žiberna, Aleš (2007): Generalized Blockmodeling of Valued Networks. Social Networks, Jan. 2007, vol. 29, no. 1, 105-126.</a></p>
<pre class="r"><code>#select partitions with optimization
blks&lt;-blockmodeling::optRandomParC(flomarr.mat, k=5, rep=10, approaches=&quot;ss&quot;, blocks=&quot;com&quot;)</code></pre>
<pre><code>## 
## 
## Starting optimization of the partiton 1 of 10 partitions.
## Starting partition: 3 4 1 4 4 4 4 4 4 4 4 2 4 4 4 5 
## Final error: 18.2 
## Final partition:    4 5 5 3 3 4 2 4 2 4 1 4 3 4 1 5 
## 
## 
## Starting optimization of the partiton 2 of 10 partitions.
## Starting partition: 3 3 3 2 3 3 3 3 3 3 5 4 1 3 3 3 
## Final error: 17.44444 
## Final partition:    3 3 3 5 5 1 4 3 4 1 2 1 5 3 2 3 
## 
## 
## Starting optimization of the partiton 3 of 10 partitions.
## Starting partition: 5 3 2 5 5 4 5 1 5 5 5 5 5 5 5 5 
## Final error: 18.2 
## Final partition:    5 2 2 4 4 5 1 5 1 5 3 5 4 5 3 2 
## 
## 
## Starting optimization of the partiton 4 of 10 partitions.
## Starting partition: 1 1 5 1 2 4 3 1 1 1 1 1 1 1 1 1 
## Final error: 17.44444 
## Final partition:    1 1 1 2 2 4 3 1 3 4 5 4 2 1 5 1 
## 
## 
## Starting optimization of the partiton 5 of 10 partitions.
## Starting partition: 3 4 3 2 5 2 2 3 2 3 1 1 5 3 4 3 
## Final error: 19.52 
## Final partition:    3 2 3 1 1 3 2 3 2 4 5 3 2 4 5 2 
## 
## 
## Starting optimization of the partiton 6 of 10 partitions.
## Starting partition: 1 5 4 3 2 3 5 1 4 3 4 3 2 5 1 2 
## Final error: 16.69167 
## Final partition:    4 4 4 5 5 1 1 1 3 1 5 1 2 4 5 2 
## 
## 
## Starting optimization of the partiton 7 of 10 partitions.
## Starting partition: 5 4 3 2 1 4 1 1 5 5 4 5 2 1 1 1 
## Final error: 17.14444 
## Final partition:    4 1 4 3 3 2 2 2 5 2 3 2 4 1 3 1 
## 
## 
## Starting optimization of the partiton 8 of 10 partitions.
## Starting partition: 5 5 5 5 5 5 5 5 5 3 1 5 5 5 2 4 
## Final error: 16.50556 
## Final partition:    1 1 1 5 5 3 2 2 4 3 5 3 1 1 5 1 
## 
## 
## Starting optimization of the partiton 9 of 10 partitions.
## Starting partition: 5 3 2 2 4 5 5 5 1 2 3 3 5 2 4 3 
## Final error: 16.50556 
## Final partition:    5 5 5 1 1 3 4 4 2 3 1 3 5 5 1 5 
## 
## 
## Starting optimization of the partiton 10 of 10 partitions.
## Starting partition: 5 1 3 2 5 4 4 2 3 3 5 2 4 1 1 5 
## Final error: 18.08333 
## Final partition:    2 1 2 3 3 2 5 2 5 4 3 2 2 4 3 1 
## 
## 
## Optimization of all partitions completed
## 2 solution(s) with minimal error = 16.50556 found.</code></pre>
<pre class="r"><code>#blockmodel with optimized partition
blk_mod &lt;- blockmodel(flomarr.stat, blks$best$best1$clu, plabels=rownames(flomarr.mat)) 
#print blockmodel object
blk_mod$block.model</code></pre>
<pre><code>##            Block 1   Block 2   Block 3 Block 4    Block 5
## Block 1 0.06666667 0.1666667 0.1111111       1 0.08333333
## Block 2 0.16666667 1.0000000 0.0000000       0 0.12500000
## Block 3 0.11111111 0.0000000 0.0000000       0 0.00000000
## Block 4 1.00000000 0.0000000 0.0000000     NaN 0.00000000
## Block 5 0.08333333 0.1250000 0.0000000       0 0.83333333</code></pre>
<pre class="r"><code>#plot blockmodel partitions
plot.block(blk_mod,main=&quot;Florentine Marriages, Optimized 5 Partitions&quot;, cex.lab=.5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-28-1.png" width="100%" /></p>
<pre class="r"><code>#assign block membership to vertex attribute
flomarr.stat%v%&quot;role&quot;&lt;-blk_mod$block.membership[match(flomarr.stat%v%&quot;vertex.names&quot;,blk_mod$plabels)]
#plot network using &quot;role&quot; to color nodes
GGally::ggnet2(flomarr.stat,
               node.color=&quot;role&quot;, 
               node.size=degree(flomarr.stat, gmode=&quot;graph&quot;),
               node.label = &quot;vertex.names&quot;,
               node.alpha = .5)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-28-2.png" width="100%" /></p>
<p>A long list of other options are available, see the help file (online or in R) for more details. Note that the optimization routine is computationally intensive, and large networks (over 100 vertices) can take hours or even days.</p>
<div id="section-exercise-optimization" class="section level3">
<h3>Exercise: Optimization</h3>
<p>Using one of the alternative networks for the week, go through the position extraction routine using criteron-based partition optimization. How do the resulting network partitions compare to the ones identified using other approaches? Can you interpret any differences you find in the position of specific nodes? You may want to experiment with changes in the options for <code>k=...</code>, <code>approaches=&quot; &quot;</code>, or perhaps using a pre-specified partition set using a different partitioning method or perhaps measures of network centrality such as derived and reflected centrality or gould-fernandez brokerage that approximate network position or role.</p>
<div class="tutorial-exercise" data-label="criterion" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="12">
<pre class="text"><code>#select partitions with optimization

#blockmodel with optimized partition

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.timelimit":10,"exercise.checker":"NULL"}</script>
</div>
<div class="tutorial-exercise-support" data-label="criterion-solution" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>#select partitions with optimization

#blockmodel with optimized partition

#print blockmodel object

#plot blockmodel partitions

#assign block membership to vertex attribute

#plot network using &quot;role&quot; to color nodes</code></pre>
</div>
</div>
</div>
<div id="section-regular-equivalence" class="section level2">
<h2><strong>Regular Equivalence</strong></h2>
<p>Functional or regular equivalence allows for similarity of relationship patterns without exact neighbor sharing. While intuitively simple to imagine roles such as <em>husband</em> and <em>wife</em> or <em>parent</em> and <em>child</em>, such general roles are computationally difficult to identify. Two algorithms that are often used are CATREGE, or categorical regular equivalence, for directed networks with categorical or binary ties. The REGE algorithm is used for valued ties, either directed or undirected. Geodesic distances can also be used as a distance matrix in REGE even when the original ties are binary.</p>
<pre class="r"><code>#calculate equivalence from specified distance marix
flomarr.re&lt;-equiv.clust(flomarr.stat, equiv.fun=&quot;redist&quot;, method=&quot;catrege&quot;, mode=&quot;graph&quot;)
#plot equivalence clustering
plot(flomarr.re,labels=flomarr.se$glabels)</code></pre>
<p><img src="NetRoles_files/figure-html/unnamed-chunk-29-1.png" width="100%" /></p>
<p>The issue that can clearly be seen is that regular equivalence is pretty uninteresting, at least for an unweighted and undirected graph. One option is to set the option <code>seed.partition=...</code> and provide an initial equivalence partition to serve as a starting point for the algorithm - perhaps a partition obtained using one of the other approaches provided earlier.</p>
The REGE algorithm is availble in the blockmodeling package by calling <code>REGE(...)</code> and providing a matrix. This algorithm works with valued or weighted networks, but like CATREGE the results are uninteresting for unweighted and undirected networks. 
<script type="application/shiny-prerendered" data-context="server-start">
#if("concoR"   %in% rownames(installed.packages()) == FALSE) {devtools::install_github("aslez/concoR")}
library(learnr)
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(statnet)
library(tidyverse)
load("Week6.rdata")
tutorial_options(exercise.timelimit = 10)
plot.block<-function(x=blk_mod, main=NULL, cex.lab=1){
  plot.sociomatrix(x$blocked.data, labels=list(x$plabels,x$plabels),
                   main=main, drawlines = FALSE, cex.lab=cex.lab)
  for (j in 2:length(x$plabels)) if (x$block.membership[j] !=
                                     x$block.membership[j-1]) 
    abline(v = j - 0.5, h = j - 0.5, lty = 3)
}
knitr::opts_knit$set(global.par = TRUE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-describe-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-describe-code-editor`)), session)
output$`tutorial-exercise-describe-output` <- renderUI({
  `tutorial-exercise-describe-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-structure-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-structure-code-editor`)), session)
output$`tutorial-exercise-structure-output` <- renderUI({
  `tutorial-exercise-structure-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-nodes-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-nodes-code-editor`)), session)
output$`tutorial-exercise-nodes-output` <- renderUI({
  `tutorial-exercise-nodes-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-sedist-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-sedist-code-editor`)), session)
output$`tutorial-exercise-sedist-output` <- renderUI({
  `tutorial-exercise-sedist-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-plotequiv-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-plotequiv-code-editor`)), session)
output$`tutorial-exercise-plotequiv-output` <- renderUI({
  `tutorial-exercise-plotequiv-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-partition-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-partition-code-editor`)), session)
output$`tutorial-exercise-partition-output` <- renderUI({
  `tutorial-exercise-partition-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-block-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-block-code-editor`)), session)
output$`tutorial-exercise-block-output` <- renderUI({
  `tutorial-exercise-block-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-roleplot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-roleplot-code-editor`)), session)
output$`tutorial-exercise-roleplot-output` <- renderUI({
  `tutorial-exercise-roleplot-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-roles and cent-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-roles and cent-code-editor`)), session)
output$`tutorial-exercise-roles and cent-output` <- renderUI({
  `tutorial-exercise-roles and cent-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-weighted-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-weighted-code-editor`)), session)
output$`tutorial-exercise-weighted-output` <- renderUI({
  `tutorial-exercise-weighted-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-concor-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-concor-code-editor`)), session)
output$`tutorial-exercise-concor-output` <- renderUI({
  `tutorial-exercise-concor-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-criterion-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-criterion-code-editor`)), session)
output$`tutorial-exercise-criterion-output` <- renderUI({
  `tutorial-exercise-criterion-result`()
})
</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.11"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["4.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["localforage"]},{"type":"character","attributes":{},"value":["1.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/localforage"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["localforage.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103]}},"value":[{"type":"character","attributes":{},"value":["assertthat","backports","base","bibtex","blockmodeling","broom","cellranger","cli","coda","codetools","colorspace","compiler","concoR","crayon","datasets","DEoptimR","digest","doParallel","doRNG","dplyr","ergm","ergm.count","evaluate","forcats","foreach","generics","GGally","ggplot2","glue","graphics","grDevices","grid","gtable","haven","hms","htmltools","htmlwidgets","httpuv","httr","igraph","iterators","jsonlite","knitr","later","lattice","lazyeval","learnr","lpSolve","lubridate","magrittr","markdown","MASS","Matrix","methods","mime","modelr","munsell","network","networkDynamic","nlme","parallel","pillar","pkgconfig","pkgmaker","plyr","promises","purrr","R6","RColorBrewer","Rcpp","readr","readxl","registry","reshape","rlang","rmarkdown","rngtools","robustbase","rprojroot","rstudioapi","rvest","scales","shiny","sna","statnet","statnet.common","stats","stringi","stringr","tergm","tibble","tidyr","tidyselect","tidyverse","tools","trust","tsna","utils","withr","xfun","xml2","xtable","yaml"]},{"type":"character","attributes":{},"value":["0.2.0","1.1.3","3.5.2","0.4.2","0.3.4","0.5.1","1.1.0","1.0.1","0.19-2","0.2-15","1.4-0","3.5.2","0.1","1.3.4","3.5.2","1.0-8","0.6.18","1.0.14","1.7.1","0.8.0.1","3.9.4","3.3.0","0.12","0.3.0","1.4.4","0.0.2","1.4.0","3.1.0","1.3.0","3.5.2","3.5.2","3.5.2","0.2.0","2.0.0","0.4.2","0.3.6","1.3","1.4.5.1","1.4.0","1.2.2","1.0.10","1.6","1.21","0.7.5","0.20-38","0.2.1","0.9.2.1","5.6.13","1.7.4","1.5","0.9","7.3-51.1","1.2-15","3.5.2","0.6","0.1.2","0.5.0","1.13.0.1","0.9.0","3.1-137","3.5.2","1.3.1","2.0.2","0.27","1.8.4","1.0.1","0.3.0","2.4.0","1.1-2","1.0.0","1.3.1","1.2.0","0.5","0.8.8","0.3.1","1.11","1.3.1","0.93-3","1.3-2","0.9.0","0.3.2","1.0.0","1.2.0","2.4","2018.10","4.2.0","3.5.2","1.3.1","1.4.0","3.5.2","2.0.1","0.8.2","0.2.5","1.2.1","3.5.2","0.1-7","0.2.0","3.5.2","2.1.2","0.4","1.2.0","1.8-3","2.2.0"]}]}]}
</script>
<!--/html_preserve-->
</div>

</div> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h2 class="title toc-ignore" style="display:none;">Week 6 Syntax Notebook</h2>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</div> <!-- bandContent page -->
</div> <!-- pageContent band -->




<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>

</html>
